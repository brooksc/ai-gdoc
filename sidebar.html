<!DOCTYPE html>
<html>
<!-- Mon Feb 24 14:36:52 PST 2025 -->
  <head>
    <base target="_top">
    <meta charset="utf-8">
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 10px;
        color: #444;
      }
      h3 {
        color: #1a73e8;
        margin-bottom: 15px;
        padding-right: 24px;
      }
      .sidebar-fix {
        width: 100%;
        max-width: 280px;
        box-sizing: border-box;
      }
      #sidebar-header {
        position: relative;
        margin-right: 20px;
      }
      .container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        padding-right: 5px;
      }
      .model-selector {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      .ai-comment-counter {
        background: #e8f0fe;
        border-radius: 4px;
        padding: 10px;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .counter-badge {
        background: #1a73e8;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }
      button {
        background-color: #1a73e8;
        color: white;
        border: none;
        padding: 10px 16px;
        font-size: 14px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: #1765cc;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }
      
      /* Logging section styles */
      .logging-section {
        margin-top: 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #fff;
      }
      
      .logging-header {
        display: flex;
        align-items: center;
        padding: 8px;
        background: #f8f9fa;
        border-bottom: 1px solid #ddd;
        border-radius: 4px 4px 0 0;
      }
      
      .logging-header h4 {
        margin: 0;
        flex-grow: 1;
        color: #1a73e8;
        font-size: 14px;
      }
      
      .copy-button, .clear-button, .refresh-button {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 8px;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
      }
      
      .copy-button:hover, .clear-button:hover, .refresh-button:hover {
        background: #f1f3f4;
      }
      
      .unified-logs {
        width: 100%;
        height: 300px;
        padding: 8px;
        font-family: 'Roboto Mono', monospace;
        font-size: 12px;
        border: none;
        resize: vertical;
        background: #fff;
        color: #444;
        line-height: 1.4;
        white-space: pre-wrap;
        overflow-y: auto;
      }
      
      .unified-logs:focus {
        outline: none;
        border-color: #1a73e8;
      }
      
      /* Add styles for different log categories */
      .log-error { color: #d93025; }
      .log-debug { color: #188038; }
      .log-comment { color: #1a73e8; }
      .log-text { color: #666; }
      .log-state { color: #9334e6; }
      .log-nux { color: #9c27b0; font-weight: bold; }
      
      /* Debug info panel */
      .debug-info-panel {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 10px;
        font-size: 12px;
      }
      
      .debug-info-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
      }
      
      .debug-info-label {
        font-weight: bold;
        color: #5f6368;
      }

      .debug-info-value {
        font-family: 'Roboto Mono', monospace;
      }
      
      .progress-container {
        margin-top: 15px;
      }
      .progress-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        font-size: 13px;
      }
      .current-processing {
        background: #fef7e0;
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 15px;
      }
      .streaming-response {
        background: #f8f9fa;
        border-radius: 4px;
        padding: 12px;
        margin-top: 8px;
      }
      .streaming-text {
        max-height: 150px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
        margin-top: 8px;
        padding: 8px;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      .revision-item {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 8px;
      }
      .revision-item h4 {
        margin: 0 0 8px 0;
        color: #188038;
      }
      .button-group {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }
      .accept-button {
        background-color: #188038;
      }
      .accept-button:hover {
        background-color: #137333;
      }
      .reject-button {
        background-color: #d93025;
      }
      .reject-button:hover {
        background-color: #c5221f;
      }
      .status {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 11px;
        margin-left: 5px;
      }
      .status-pending {
        background: #f1f3f4;
        color: #444;
      }
      .status-processing {
        background: #fef7e0;
        color: #b06000;
      }
      .status-completed {
        background: #e6f4ea;
        color: #137333;
      }
      .status-error {
        background: #fce8e6;
        color: #c5221f;
      }
      .refresh-models {
        font-size: 12px;
        color: #1a73e8;
        text-decoration: underline;
        cursor: pointer;
        margin-left: auto;
        border: none;
        background: none;
        padding: 0;
      }
      .cancel-button {
        background-color: #5f6368;
      }
      .cancel-button:hover {
        background-color: #494c50;
      }
      .processing-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 16px;
        z-index: 1000;
      }
      
      .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #1a73e8;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      .text-block {
        background: #f8f9fa;
        padding: 8px;
        border-radius: 3px;
        border: 1px solid #ddd;
        margin-bottom: 10px;
        font-size: 13px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      
      .diff-view {
        margin: 8px 0;
      }
      
      .diff-removed {
        background-color: #ffebe9;
        text-decoration: line-through;
        color: #cf222e;
        padding: 4px;
        border-radius: 3px;
        margin-bottom: 4px;
      }
      
      .diff-added {
        background-color: #e6f4ff;
        color: #0969da;
        padding: 4px;
        border-radius: 3px;
      }
      
      /* Settings styles */
      .settings-button {
        background-color: #f1f3f4;
        color: #444;
        padding: 8px 12px;
        width: 100%;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 15px;
      }
      
      .settings-panel {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 12px;
        margin-top: 8px;
        display: none;
      }
      
      .toggle-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 42px;
        height: 20px;
      }
      
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        border-radius: 10px;
        transition: .4s;
      }
      
      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        border-radius: 50%;
        transition: .4s;
      }
      
      input:checked + .toggle-slider {
        background-color: #1a73e8;
      }
      
      input:checked + .toggle-slider:before {
        transform: translateX(20px);
      }
      
      /* Document-wide prompt feature */
      .doc-prompt-container {
        margin-top: 0;
        padding: 15px;
        background: #f0f7ff;
        border-radius: 4px;
        border: 1px solid #d0e3ff;
        display: none;
      }
      
      .doc-prompt-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #1a73e8;
      }
      
      .prompt-textarea {
        width: 100%;
        min-height: 80px;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
        margin-bottom: 10px;
        resize: vertical;
      }
      
      .prompt-library-container {
        margin-bottom: 10px;
      }
      
      .prompt-library-select {
        width: 100%;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
        margin-bottom: 5px;
      }
      
      .prompt-save-container {
        display: flex;
        margin-top: 5px;
        gap: 5px;
      }
      
      .prompt-save-input {
        flex-grow: 1;
        padding: 5px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      
      /* Debug section */
      .debug-section {
        margin-top: 10px;
        display: none;
      }
      
      /* Help section */
      .help-section {
        margin-top: 15px;
        background: #f0f7ff;
        border-radius: 4px;
        padding: 12px;
        font-size: 13px;
      }
      
      .help-section h3 {
        margin-top: 0;
        font-size: 16px;
      }
      
      .help-section ol {
        margin: 0;
        padding-left: 20px;
      }
      
      /* Getting Started Section styles */
      .help-content {
        padding: 10px;
        font-size: 13px;
      }
      
      .help-content h4 {
        color: #1a73e8;
        margin-top: 0;
        margin-bottom: 10px;
      }
      
      .help-content p {
        margin-bottom: 15px;
        line-height: 1.4;
      }
      
      .help-step, .help-tip {
        background: #f8f9fa;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 15px;
        border-left: 3px solid #1a73e8;
      }
      
      .help-tip {
        border-left-color: #fbbc04;
        background: #fffee0;
      }
      
      .help-step h5, .help-tip h5 {
        margin-top: 0;
        margin-bottom: 5px;
        color: #202124;
      }
      
      .help-step ul, .help-step ol, .help-tip ul {
        margin-top: 5px;
        margin-bottom: 5px;
        padding-left: 20px;
      }
      
      .help-step li, .help-tip li {
        margin-bottom: 3px;
      }
      
      /* New UI Section styles */
      .section-header {
        background-color: #f1f3f4;
        color: #444;
        padding: 10px 16px;
        width: 100%;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-radius: 4px;
        margin-bottom: 8px;
        cursor: pointer;
        font-weight: bold;
      }
      
      .section-header.active {
        background-color: #d2e3fc;
        color: #1a73e8;
      }
      
      .section-content {
        display: none;
        padding: 10px 0;
        border-bottom: 1px solid #e0e0e0;
        margin-bottom: 10px;
      }
      
      .section-content.active {
        display: block;
      }
      
      .subsection-header {
        background-color: #f8f9fa;
        color: #444;
        padding: 8px 12px;
        border-radius: 4px;
        margin-bottom: 8px;
        cursor: pointer;
        font-weight: normal;
        display: flex;
        align-items: center;
      }
      
      .subsection-header input[type="radio"] {
        margin-right: 8px;
      }
      
      .subsection-content {
        display: none;
        padding: 8px 8px 8px 24px;
        margin-bottom: 8px;
      }
      
      .subsection-content.active {
        display: block;
      }
      
      /* Suggestion review styles */
      .suggestion-container {
        margin-top: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        overflow: hidden;
      }
      
      .suggestion-navigation {
        display: flex;
        justify-content: space-between;
        padding: 8px;
        background-color: #f1f3f4;
        border-bottom: 1px solid #ddd;
      }
      
      .suggestion-count {
        display: flex;
        align-items: center;
        font-size: 14px;
        color: #444;
      }
      
      .suggestion-content {
        padding: 16px;
      }
      
      .suggestion-original, .suggestion-revised {
        margin-bottom: 10px;
      }
      
      .suggestion-label {
        font-weight: bold;
        margin-bottom: 4px;
        font-size: 14px;
      }
      
      .suggestion-text {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ddd;
        background-color: #fff;
        font-size: 13px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      
      .suggestion-original .suggestion-text {
        background-color: #ffebe9;
        text-decoration: line-through;
        color: #cf222e;
      }
      
      .suggestion-revised .suggestion-text {
        background-color: #e6f4ff;
        color: #0969da;
      }
      
      .suggestion-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 16px;
      }
      
      .nav-button {
        background-color: #f1f3f4;
        color: #444;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
      }
      
      .nav-button:hover {
        background-color: #e0e0e0;
      }
      
      .nav-button:disabled {
        background-color: #f1f3f4;
        color: #bbb;
        cursor: not-allowed;
      }
      
      .api-key-section {
        margin-top: 10px;
      }
      
      .api-key-input {
        width: 100%;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
        margin-bottom: 8px;
      }
      
      .api-key-label {
        display: block;
        margin-bottom: 4px;
        font-size: 14px;
      }
      
      .timeout-section {
        margin-top: 10px;
      }
      
      .timeout-input {
        width: 80px;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      
      .timeout-label {
        display: block;
        margin-bottom: 4px;
        font-size: 14px;
      }
    </style>
  </head>
  <body class="sidebar-fix">
    <div id="sidebar-header">
      <h3>AI Editor</h3>
    </div>
    <div class="container">
      <!-- Section 0: Getting Started -->
      <div class="section-header" id="getting-started-header">
        <span>0. Getting Started</span>
        <span class="expand-icon">▼</span>
      </div>
      <div class="section-content" id="getting-started-section">
        <div class="help-content">
          <h4>Welcome to AI Editor!</h4>
          <p>This plugin helps you use AI to improve your Google Docs. Here's how to get started:</p>
          
          <div class="help-step">
            <h5>Step 1: Configure Settings</h5>
            <p>Go to the <strong>Settings</strong> section and:</p>
            <ul>
              <li>Select your preferred AI model</li>
              <li>For Gemini models, enter your API key</li>
              <li>Adjust timeout settings if needed</li>
            </ul>
          </div>
          
          <div class="help-step">
            <h5>Step 2: Choose How to Use AI</h5>
            <p>You can use AI in two ways:</p>
            <ol>
              <li><strong>AI-Edit Comments:</strong> Add comments starting with "AI:" followed by your instructions to specific text selections</li>
              <li><strong>AI-Edit Doc:</strong> Apply AI transformations to the entire document using prompts</li>
            </ol>
          </div>
          
          <div class="help-step">
            <h5>Step 3: Review Changes</h5>
            <p>After processing:</p>
            <ul>
              <li>Review each suggestion from the AI</li>
              <li>Accept or reject each proposed change</li>
              <li>Changes accepted will be applied directly to your document</li>
            </ul>
          </div>
          
          <div class="help-tip">
            <h5>Tips:</h5>
            <ul>
              <li>Be specific in your instructions to get better results</li>
              <li>For comment-based edits, select only the text you want to modify</li>
              <li>For document-wide edits, use the prompt templates or create your own</li>
            </ul>
          </div>
        </div>
      </div>
      
      <!-- Section 1: Select Content -->
      <div class="section-header" id="select-content-header">
        <span>1. Select Content</span>
        <span class="expand-icon">▼</span>
      </div>
      <div class="section-content active" id="select-content-section">
        <!-- Option 1: AI-Edit Comments -->
        <div class="subsection-header">
          <input type="radio" name="edit-mode" id="comments-mode" checked>
          <label for="comments-mode">AI-Edit Comments</label>
        </div>
        <div class="subsection-content active" id="comments-content">
          <div class="ai-comment-counter">
            <span>Unprocessed AI Comments:</span>
            <span class="counter-badge" id="commentCount">0</span>
          </div>
          <button id="processButton" disabled>Process AI Comments</button>
        </div>
        
        <!-- Option 2: AI-Edit Doc -->
        <div class="subsection-header">
          <input type="radio" name="edit-mode" id="document-mode">
          <label for="document-mode">AI-Edit Doc</label>
        </div>
        <div class="subsection-content" id="document-content">
          <div class="doc-prompt-container" style="display: block !important;">
            <div class="prompt-library-container">
              <select id="promptLibrarySelect" class="prompt-library-select">
                <option value="">Select a prompt template...</option>
              </select>
              <div class="prompt-save-container">
                <input type="text" id="promptSaveName" class="prompt-save-input" placeholder="Name for this prompt">
                <button id="promptSaveButton" class="prompt-save-button">Save</button>
              </div>
            </div>
            
            <textarea id="docPromptInput" class="prompt-textarea" placeholder="Enter your prompt here..."></textarea>
            
            <div class="prompt-action-container">
              <button id="docPromptSubmit" class="prompt-submit-button">Process Document</button>
              <button id="docPromptClear" class="prompt-clear-button">Clear</button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Section 2: Review Proposed Changes -->
      <div class="section-header" id="review-changes-header">
        <span>2. Review Proposed Changes</span>
        <span class="expand-icon">▼</span>
      </div>
      <div class="section-content" id="review-changes-section">
        <div id="suggestion-review-container" style="display: none;">
          <div class="suggestion-container">
            <div class="suggestion-navigation">
              <button class="nav-button" id="prev-suggestion" disabled>&lt; Previous</button>
              <div class="suggestion-count">Suggestion <span id="current-suggestion">0</span> of <span id="total-suggestions">0</span></div>
              <button class="nav-button" id="next-suggestion" disabled>Next &gt;</button>
            </div>
            <div class="suggestion-content">
              <div class="suggestion-original">
                <div class="suggestion-label">Original Text:</div>
                <div class="suggestion-text" id="original-text"></div>
              </div>
              <div class="suggestion-revised">
                <div class="suggestion-label">Revised Text:</div>
                <div class="suggestion-text" id="revised-text"></div>
              </div>
              <div class="suggestion-actions">
                <button class="accept-button" id="accept-suggestion">Accept</button>
                <button class="reject-button" id="reject-suggestion">Reject</button>
              </div>
            </div>
          </div>
        </div>
        
        <div id="comment-revisions-container">
          <div id="currentProcessing"></div>
          <div id="revisionsList"></div>
        </div>
        
        <div id="progress"></div>
      </div>
      
      <!-- Section 3: Settings -->
      <div class="section-header" id="settings-header">
        <span>3. Settings</span>
        <span class="expand-icon">▼</span>
      </div>
      <div class="section-content" id="settings-section">
        <div class="model-selector">
          <div style="display: flex; align-items: center;">
            <label for="modelSelect">Select Model:</label>
            <button class="refresh-models" id="refreshModels">Refresh</button>
          </div>
          <select id="modelSelect">
            <option value="">Loading models...</option>
            <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
            <option value="llama3:latest">Llama 3 (Ollama)</option>
            <option value="mistral:latest">Mistral (Ollama)</option>
            <option value="mixtral:latest">Mixtral (Ollama)</option>
            <option value="phi3:latest">Phi-3 (Ollama)</option>
            <option value="qwen:latest">Qwen (Ollama)</option>
          </select>
        </div>
        
        <!-- Gemini API Key section -->
        <div class="api-key-section gemini-api-fields">
          <label for="geminiApiKey" class="api-key-label">Gemini API Key:</label>
          <input type="password" id="geminiApiKey" class="api-key-input" placeholder="Enter your Gemini API Key">
          <button id="saveApiKey" class="prompt-save-button">Save API Key</button>
        </div>
        
        <!-- Timeout setting -->
        <div class="timeout-section">
          <label for="timeoutSetting" class="timeout-label">API Timeout (seconds):</label>
          <input type="number" id="timeoutSetting" class="timeout-input" min="30" max="600" value="300">
        </div>
        
        <!-- Debug toggle -->
        <div class="toggle-row">
          <span>Show Debug Tools</span>
          <label class="toggle-switch">
            <input type="checkbox" id="debug-toggle">
            <span class="toggle-slider"></span>
          </label>
        </div>
        
        <button id="saveSettings" class="prompt-submit-button">Save Settings</button>
      </div>
      
      <!-- Debug section -->
      <div id="debugSection" class="debug-section">
        <!-- Debug button -->
        <button id="debugButton" style="background-color: #ff9800; margin-bottom: 10px; width: 100%;">Debug: Test First Comment</button>
        
        <!-- Reset NUX button -->
        <button id="resetNuxButton" style="background-color: #9c27b0; margin-bottom: 10px; width: 100%;">Reset New User Experience</button>
        
        <!-- Unified logging section -->
        <div class="logging-section" style="margin-bottom: 20px;">
          <div class="logging-header">
            <h4>Debug Logs</h4>
            <button id="copyLogsButton" class="copy-button" title="Copy logs to clipboard">
              <span class="copy-icon">📋</span> Copy
            </button>
            <button id="clearLogsButton" class="clear-button" title="Clear logs">
              <span class="clear-icon">🗑️</span> Clear
            </button>
            <button id="refreshLogsButton" class="refresh-button" title="Refresh logs">
              <span class="refresh-icon">🔄</span> Refresh
            </button>
          </div>
          <textarea id="unifiedLogs" readonly class="unified-logs" 
                    placeholder="Debug logs will appear here..."></textarea>
        </div>
      </div>
    </div>

    <div id="processingOverlay" class="processing-overlay" style="display: none;">
      <div class="spinner"></div>
      <div id="processingStatus">Processing...</div>
      <button class="cancel-button" onclick="cancelProcessing()">Cancel</button>
    </div>

    <!-- Debug Info Panel -->
    <div id="debugInfoPanel" class="debug-info-panel" style="display: none;">
      <div class="debug-info-row">
        <span class="debug-info-label">Last NUX Reset:</span>
        <span class="debug-info-value" id="lastNuxReset">Never</span>
      </div>
      <div class="debug-info-row">
        <span class="debug-info-label">First Time User:</span>
        <span class="debug-info-value" id="firstTimeUserStatus">Unknown</span>
      </div>
    </div>
    
    <!-- Debug Logs -->
    <div id="debugLogsContainer">
      <pre id="debugLogs" class="unified-logs"></pre>
    </div>

    <script>
      // Global state
      let commentsList = [];
      let selectedModel = '';
      let isProcessing = false;
      let fileId = '';
      let currentComment = null;
      let isCancelled = false;
      let processingTimeout = null;
      let isApiCallInProgress = false;
      
      // Suggestion review state
      let currentSuggestions = [];
      let currentSuggestionIndex = -1;
      
      // Constants
      const TIMEOUT_MS = 300000; // 300 second timeout (5 minutes)
      
      // Initialize settings
      let userSettings = {
        showDebugTools: false,
        timeout: TIMEOUT_MS,
        geminiApiKey: ''
      };
      
      // Define the prompt library with default prompts
      const promptLibrary = {
        DEFAULT_PROMPTS: [
          {
            name: "Improve Clarity",
            prompt: "Improve the clarity of this text while maintaining its original meaning. Make it more concise and easier to understand."
          },
          {
            name: "Fix Grammar & Spelling",
            prompt: "Correct any grammar, spelling, or punctuation errors in this text without changing its meaning."
          },
          {
            name: "Make More Formal",
            prompt: "Rewrite this text in a more formal and professional tone while preserving the original meaning."
          },
          {
            name: "Make More Casual",
            prompt: "Rewrite this text in a more casual and conversational tone while preserving the original meaning."
          },
          {
            name: "Strengthen Argument",
            prompt: "Strengthen the arguments in this text by adding more compelling evidence, logic, and persuasive language."
          },
          {
            name: "Simplify Language",
            prompt: "Simplify the language in this text to make it more accessible to a general audience. Aim for clarity and readability."
          },
          {
            name: "Add Examples",
            prompt: "Add relevant examples to illustrate the key points in this text, making the concepts more concrete and easier to understand."
          },
          {
            name: "Improve Structure",
            prompt: "Improve the structure and organization of this text to enhance flow and readability. Ensure logical progression of ideas."
          },
          {
            name: "Technical Review",
            prompt: "Review this technical content for accuracy, clarity, and completeness. Suggest improvements while maintaining technical precision."
          },
          {
            name: "Executive Summary",
            prompt: "Create a concise executive summary of this document, highlighting the most important points and conclusions."
          }
        ],
        savedPrompts: []
      };
      
      // Initialize the prompt library
      function initPromptLibrary() {
        // Ensure the document-wide prompt container is visible
        const docPromptContainer = document.querySelector('.doc-prompt-container');
        console.log('Document prompt container found:', !!docPromptContainer);
        if (docPromptContainer) {
          docPromptContainer.style.display = 'block';
          console.log('Made document prompt container visible');
        } else {
          console.error('Could not find document prompt container');
        }
        
        // Load saved prompts from server
        google.script.run
          .withSuccessHandler(function(promptsJson) {
            if (promptsJson) {
              try {
                const savedPrompts = JSON.parse(promptsJson);
                promptLibrary.savedPrompts = savedPrompts;
                console.log(`Loaded ${savedPrompts.length} saved prompts`);
              } catch (e) {
                console.error("Error parsing saved prompts:", e);
              }
            }
            
            // Populate the prompt dropdown
            populatePromptDropdown();
          })
          .withFailureHandler(function(error) {
            console.error("Failed to load prompt library:", error);
          })
          .getPromptLibrary();
        
        // Set up event listeners for prompt library
        document.getElementById('promptLibrarySelect').addEventListener('change', handlePromptSelect);
        document.getElementById('promptSaveButton').addEventListener('click', savePrompt);
        document.getElementById('docPromptSubmit').addEventListener('click', processDocumentWithInlineSuggestions);
        document.getElementById('docPromptClear').addEventListener('click', clearDocumentPrompt);
      }
      
      // Populate the prompt dropdown with default and saved prompts
      function populatePromptDropdown() {
        // ... existing code ...
      }
      
      // Handle prompt selection from dropdown
      function handlePromptSelect(e) {
        // ... existing code ...
      }
      
      // Save a new prompt to the library
      function savePrompt() {
        // ... existing code ...
      }
      
      // Initialize collapsible sections
      function initSections() {
        const sections = [
          { header: 'getting-started-header', content: 'getting-started-section' },
          { header: 'select-content-header', content: 'select-content-section' },
          { header: 'review-changes-header', content: 'review-changes-section' },
          { header: 'settings-header', content: 'settings-section' }
        ];
        
        // Set up click handlers for section headers
        sections.forEach(section => {
          const headerElement = document.getElementById(section.header);
          const contentElement = document.getElementById(section.content);
          
          headerElement.addEventListener('click', () => {
            // Toggle this section
            const isActive = headerElement.classList.contains('active');
            
            // First close all sections
            sections.forEach(s => {
              document.getElementById(s.header).classList.remove('active');
              document.getElementById(s.content).classList.remove('active');
              document.getElementById(s.content).style.display = 'none';
              
              // Update arrow icon
              const arrow = document.getElementById(s.header).querySelector('.expand-icon');
              arrow.textContent = '▼';
            });
            
            // Then open this section if it wasn't already open
            if (!isActive) {
              headerElement.classList.add('active');
              contentElement.classList.add('active');
              contentElement.style.display = 'block';
              
              // Update arrow icon
              const arrow = headerElement.querySelector('.expand-icon');
              arrow.textContent = '▲';
            }
          });
        });
        
        // Check if first time user
        checkFirstTimeUser().then(isFirstTime => {
          if (isFirstTime) {
            // Show Getting Started section for first-time users
            document.getElementById('getting-started-header').classList.add('active');
            document.getElementById('getting-started-section').classList.add('active');
            document.getElementById('getting-started-section').style.display = 'block';
            document.getElementById('getting-started-header').querySelector('.expand-icon').textContent = '▲';
          } else {
            // For returning users, show Select Content section by default
            document.getElementById('select-content-header').classList.add('active');
            document.getElementById('select-content-section').classList.add('active');
            document.getElementById('select-content-section').style.display = 'block';
            document.getElementById('select-content-header').querySelector('.expand-icon').textContent = '▲';
          }
        });
      }
      
      // Initialize subsections
      function initSubsections() {
        const commentsModeRadio = document.getElementById('comments-mode');
        const documentModeRadio = document.getElementById('document-mode');
        const commentsContent = document.getElementById('comments-content');
        const documentContent = document.getElementById('document-content');
        
        commentsModeRadio.addEventListener('change', () => {
          if (commentsModeRadio.checked) {
            commentsContent.classList.add('active');
            commentsContent.style.display = 'block';
            documentContent.classList.remove('active');
            documentContent.style.display = 'none';
          }
        });
        
        documentModeRadio.addEventListener('change', () => {
          if (documentModeRadio.checked) {
            documentContent.classList.add('active');
            documentContent.style.display = 'block';
            commentsContent.classList.remove('active');
            commentsContent.style.display = 'none';
          }
        });
      }
      
      // Function to process the document and get inline suggestions
      function processDocumentWithInlineSuggestions() {
        const promptInput = document.getElementById('docPromptInput');
        const prompt = promptInput.value.trim();
        
        if (!prompt) {
          alert('Please enter a prompt');
          return;
        }
        
        if (!selectedModel) {
          alert('Please select a model');
          return;
        }
        
        // Check if a Gemini API key is needed and entered when using Gemini models
        if (selectedModel.startsWith('gemini')) {
          const geminiApiKey = document.getElementById('geminiApiKey').value.trim();
          if (!geminiApiKey) {
            alert('Please enter a Gemini API key in the Settings section');
            
            // Open the settings section automatically
            document.getElementById('settings-header').click();
            document.getElementById('geminiApiKey').focus();
            return;
          }
        }
        
        if (isProcessing) {
          alert('Please wait for the current process to complete');
          return;
        }
        
        // Show processing overlay
        showProcessingOverlay('Processing document for suggested changes...');
        isProcessing = true;
        updateProcessButtonState();
        
        // Close the select content section and open the review changes section
        document.getElementById('select-content-header').classList.remove('active');
        document.getElementById('select-content-section').classList.remove('active');
        document.getElementById('select-content-section').style.display = 'none';
        document.getElementById('select-content-header').querySelector('.expand-icon').textContent = '▼';
        
        document.getElementById('review-changes-header').classList.add('active');
        document.getElementById('review-changes-section').classList.add('active');
        document.getElementById('review-changes-section').style.display = 'block';
        document.getElementById('review-changes-header').querySelector('.expand-icon').textContent = '▲';
        
        // Call the server to process the document
        google.script.run
          .withSuccessHandler(function(result) {
            hideProcessingOverlay();
            isProcessing = false;
            updateProcessButtonState();
            
            if (!result || !result.success) {
              // Show error message
              const progressElement = document.getElementById('progress');
              const errorMessage = document.createElement('div');
              errorMessage.className = 'progress-item status-error';
              errorMessage.innerHTML = `<strong>Error:</strong> ${escapeHtml(result.error || 'Unknown error')}`;
              progressElement.insertBefore(errorMessage, progressElement.firstChild);
              return;
            }
            
            // If no suggestions were found
            if (result.totalSuggestions === 0) {
              const progressElement = document.getElementById('progress');
              const message = document.createElement('div');
              message.className = 'progress-item status-completed';
              message.innerHTML = `<strong>Completed:</strong> No suggestions found for this document.`;
              progressElement.insertBefore(message, progressElement.firstChild);
              return;
            }
            
            // If some suggestions couldn't be located
            if (result.unlocatedCount > 0) {
              const progressElement = document.getElementById('progress');
              const warningMessage = document.createElement('div');
              warningMessage.className = 'progress-item status-processing';
              warningMessage.innerHTML = `<strong>Note:</strong> ${result.unlocatedCount} out of ${result.totalSuggestions} suggestions couldn't be located in the document.`;
              progressElement.insertBefore(warningMessage, progressElement.firstChild);
            }
            
            // Store the suggestions and show the first one
            currentSuggestions = result.suggestions;
            
            // Add success message
            const progressElement = document.getElementById('progress');
            const successMessage = document.createElement('div');
            successMessage.className = 'progress-item status-completed';
            successMessage.innerHTML = `<strong>Completed:</strong> Found ${currentSuggestions.length} suggestions for review.`;
            progressElement.insertBefore(successMessage, progressElement.firstChild);
            
            // Show the suggestion review UI
            document.getElementById('suggestion-review-container').style.display = 'block';
            document.getElementById('comment-revisions-container').style.display = 'none';
            
            // Update the total count
            document.getElementById('total-suggestions').textContent = currentSuggestions.length;
            
            // Show the first suggestion
            if (currentSuggestions.length > 0) {
              navigateToSuggestion(0);
            }
          })
          .withFailureHandler(function(error) {
            hideProcessingOverlay();
            isProcessing = false;
            updateProcessButtonState();
            
            // Show error message
            const progressElement = document.getElementById('progress');
            const errorMessage = document.createElement('div');
            errorMessage.className = 'progress-item status-error';
            errorMessage.innerHTML = `<strong>Error:</strong> ${escapeHtml(error.toString())}`;
            progressElement.insertBefore(errorMessage, progressElement.firstChild);
          })
          .processDocumentForInlineSuggestions(prompt, selectedModel);
      }
      
      // Function to navigate to a specific suggestion
      function navigateToSuggestion(index) {
        if (index < 0 || index >= currentSuggestions.length) {
          return;
        }
        
        currentSuggestionIndex = index;
        
        // Update navigation buttons
        document.getElementById('prev-suggestion').disabled = (index === 0);
        document.getElementById('next-suggestion').disabled = (index === currentSuggestions.length - 1);
        
        // Update the current index display
        document.getElementById('current-suggestion').textContent = index + 1;
        
        // Display the suggestion
        const suggestion = currentSuggestions[index];
        document.getElementById('original-text').textContent = suggestion.originalText;
        document.getElementById('revised-text').textContent = suggestion.revisedText;
      }
      
      // Functions for suggestion navigation
      function navigateToPrevSuggestion() {
        if (currentSuggestionIndex > 0) {
          navigateToSuggestion(currentSuggestionIndex - 1);
        }
      }
      
      function navigateToNextSuggestion() {
        if (currentSuggestionIndex < currentSuggestions.length - 1) {
          navigateToSuggestion(currentSuggestionIndex + 1);
        }
      }
      
      // Functions for accepting/rejecting suggestions
      function acceptCurrentSuggestion() {
        if (currentSuggestionIndex < 0 || currentSuggestionIndex >= currentSuggestions.length) {
          return;
        }
        
        const suggestion = currentSuggestions[currentSuggestionIndex];
        
        // Disable buttons during processing
        document.getElementById('accept-suggestion').disabled = true;
        document.getElementById('reject-suggestion').disabled = true;
        document.getElementById('prev-suggestion').disabled = true;
        document.getElementById('next-suggestion').disabled = true;
        
        // Add a status message
        const statusText = document.createElement('div');
        statusText.className = 'status status-processing';
        statusText.textContent = 'Applying change...';
        document.getElementById('accept-suggestion').parentNode.appendChild(statusText);
        
        // Call the server to apply the change
        google.script.run
          .withSuccessHandler(function(result) {
            // Remove the status message
            statusText.remove();
            
            if (!result || !result.success) {
              // Show error message
              const errorText = document.createElement('div');
              errorText.className = 'status status-error';
              errorText.textContent = 'Error: ' + (result?.error || 'Failed to apply change');
              document.getElementById('accept-suggestion').parentNode.appendChild(errorText);
              
              // Re-enable buttons
              document.getElementById('accept-suggestion').disabled = false;
              document.getElementById('reject-suggestion').disabled = false;
              document.getElementById('prev-suggestion').disabled = (currentSuggestionIndex === 0);
              document.getElementById('next-suggestion').disabled = (currentSuggestionIndex === currentSuggestions.length - 1);
              
              // Remove error message after 3 seconds
              setTimeout(() => {
                errorText.remove();
              }, 3000);
              
              return;
            }
            
            // Show success message
            const successText = document.createElement('div');
            successText.className = 'status status-completed';
            successText.textContent = 'Change applied successfully';
            document.getElementById('accept-suggestion').parentNode.appendChild(successText);
            
            // Remove the applied suggestion from the array
            currentSuggestions.splice(currentSuggestionIndex, 1);
            
            // Update the total count
            document.getElementById('total-suggestions').textContent = currentSuggestions.length;
            
            // If no more suggestions, hide the UI
            if (currentSuggestions.length === 0) {
              document.getElementById('suggestion-review-container').style.display = 'none';
              
              // Show completion message
              const progressElement = document.getElementById('progress');
              const completionMessage = document.createElement('div');
              completionMessage.className = 'progress-item status-completed';
              completionMessage.innerHTML = '<strong>Completed:</strong> All suggestions have been reviewed.';
              progressElement.insertBefore(completionMessage, progressElement.firstChild);
              
              return;
            }
            
            // Navigate to the next suggestion (or the same index if it was the last one)
            let nextIndex = currentSuggestionIndex;
            if (nextIndex >= currentSuggestions.length) {
              nextIndex = currentSuggestions.length - 1;
            }
            
            // Remove the success message after a brief delay and show the next suggestion
            setTimeout(() => {
              successText.remove();
              navigateToSuggestion(nextIndex);
            }, 1000);
          })
          .withFailureHandler(function(error) {
            // Remove the status message
            statusText.remove();
            
            // Show error message
            const errorText = document.createElement('div');
            errorText.className = 'status status-error';
            errorText.textContent = 'Error: ' + error.toString();
            document.getElementById('accept-suggestion').parentNode.appendChild(errorText);
            
            // Re-enable buttons
            document.getElementById('accept-suggestion').disabled = false;
            document.getElementById('reject-suggestion').disabled = false;
            document.getElementById('prev-suggestion').disabled = (currentSuggestionIndex === 0);
            document.getElementById('next-suggestion').disabled = (currentSuggestionIndex === currentSuggestions.length - 1);
            
            // Remove error message after 3 seconds
            setTimeout(() => {
              errorText.remove();
            }, 3000);
          })
          .applySuggestedChange(suggestion);
      }
      
      function rejectCurrentSuggestion() {
        if (currentSuggestionIndex < 0 || currentSuggestionIndex >= currentSuggestions.length) {
          return;
        }
        
        // Remove the rejected suggestion from the array
        currentSuggestions.splice(currentSuggestionIndex, 1);
        
        // Update the total count
        document.getElementById('total-suggestions').textContent = currentSuggestions.length;
        
        // If no more suggestions, hide the UI
        if (currentSuggestions.length === 0) {
          document.getElementById('suggestion-review-container').style.display = 'none';
          
          // Show completion message
          const progressElement = document.getElementById('progress');
          const completionMessage = document.createElement('div');
          completionMessage.className = 'progress-item status-completed';
          completionMessage.innerHTML = '<strong>Completed:</strong> All suggestions have been reviewed.';
          progressElement.insertBefore(completionMessage, progressElement.firstChild);
          
          return;
        }
        
        // Navigate to the next suggestion (or the same index if it was the last one)
        let nextIndex = currentSuggestionIndex;
        if (nextIndex >= currentSuggestions.length) {
          nextIndex = currentSuggestions.length - 1;
        }
        
        navigateToSuggestion(nextIndex);
      }
      
      /**
       * Function to check if user is a first-time user
       * @returns {Promise<boolean>} Promise that resolves to true if user is a first-time user
       */
      function checkFirstTimeUser() {
        return new Promise((resolve) => {
          google.script.run
            .withSuccessHandler(function(firstTimeFlag) {
              resolve(firstTimeFlag === true);
            })
            .withFailureHandler(function(error) {
              console.error('Error checking first time user:', error);
              resolve(false); // Default to false on error
            })
            .checkFirstTimeUser();
        });
      }
      
      /**
       * Reset the New User Experience
       * Clears all user properties and settings
       */
      function resetNUX() {
        if (confirm('This will reset all your settings and preferences. Are you sure?')) {
          // Show processing overlay during reset
          showProcessingOverlay('Resetting user experience...');
          
          google.script.run
            .withSuccessHandler(function(success) {
              hideProcessingOverlay();
              if (success) {
                alert('Reset successful! The sidebar will now reload.');
                // Reload the sidebar
                google.script.host.close();
                google.script.run.showSidebar();
              } else {
                alert('Reset failed. Please try again.');
              }
            })
            .withFailureHandler(function(error) {
              hideProcessingOverlay();
              alert('Error during reset: ' + error);
            })
            .resetUserExperience();
        }
      }
      
      // Main sidebar initialization function
      function initSidebar() {
        // Set up basic UI elements
        
        // Get model selection element
        const modelSelect = document.getElementById('modelSelect');
        if (modelSelect) {
          // Set up model selection change event
          modelSelect.addEventListener('change', function() {
            // Update selected model variable
            selectedModel = this.value;
            
            // Toggle Gemini API key field visibility based on model selection
            toggleGeminiFields();
            
            // Save the selection to user preferences
            if (selectedModel) {
              // Save preference if google.script.run is available
              if (google && google.script && google.script.run) {
                google.script.run.saveModelPreference(selectedModel);
              }
            }
          });
        }
        
        // Set up Reset NUX button if it exists
        const resetNuxButton = document.getElementById('resetNuxButton');
        if (resetNuxButton) {
          resetNuxButton.addEventListener('click', resetNUX);
        }
        
        // Set up refresh models button
        const refreshButton = document.getElementById('refreshModels');
        if (refreshButton) {
          refreshButton.addEventListener('click', function() {
            fetchOllamaModels();
          });
        }
        
        // Fetch available models on startup
        fetchOllamaModels();
        
        // Try to refresh comment count if applicable
        const processButton = document.getElementById('processButton');
        if (processButton) {
          // Check for AI comments
          if (google && google.script && google.script.run) {
            google.script.run
              .withSuccessHandler(function(comments) {
                const count = Array.isArray(comments) ? comments.length : 0;
                document.getElementById('commentCount').textContent = count;
                document.getElementById('processButton').disabled = count === 0;
              })
              .getAIComments();
          }
        }
        
        // Load user settings
        if (google && google.script && google.script.run) {
          google.script.run
            .withSuccessHandler(function(settings) {
              if (settings) {
                try {
                  const parsedSettings = JSON.parse(settings);
                  userSettings = Object.assign(userSettings, parsedSettings);
                  
                  // Apply loaded settings
                  const timeoutInput = document.getElementById('timeoutSetting');
                  if (timeoutInput && userSettings.timeout) {
                    timeoutInput.value = Math.floor(userSettings.timeout / 1000);
                  }
                  
                  // Set debug toggle
                  const debugToggle = document.getElementById('debug-toggle');
                  if (debugToggle) {
                    debugToggle.checked = userSettings.showDebugTools;
                  }
                  
                  // Apply debug section visibility
                  toggleDebugSection(userSettings.showDebugTools);
                  
                  // Restore selected model if available
                  if (userSettings.selectedModel) {
                    selectedModel = userSettings.selectedModel;
                    const modelSelect = document.getElementById('modelSelect');
                    if (modelSelect) {
                      // First check if the option exists
                      let found = false;
                      for (let i = 0; i < modelSelect.options.length; i++) {
                        if (modelSelect.options[i].value === selectedModel) {
                          modelSelect.selectedIndex = i;
                          found = true;
                          break;
                        }
                      }
                      
                      // If not found, we need to wait for models to load
                      // This will be addressed when the models are fetched
                    }
                    
                    // Toggle Gemini fields based on selected model
                    toggleGeminiFields();
                  }
                } catch (error) {
                  console.error('Error parsing user settings:', error);
                }
              }
            })
            .withFailureHandler(function(error) {
              console.error('Failed to load user settings:', error);
            })
            .getUserSettings();
        }
        
        // Add event listener for debug toggle
        const debugToggle = document.getElementById('debug-toggle');
        if (debugToggle) {
          debugToggle.addEventListener('change', function() {
            toggleDebugSection(this.checked);
          });
        }
        
        // Set up save settings button
        const saveSettingsButton = document.getElementById('saveSettings');
        if (saveSettingsButton) {
          saveSettingsButton.addEventListener('click', saveSettings);
        }
        
        // Add event listeners for debug buttons
        const refreshLogsButton = document.getElementById('refreshLogsButton');
        if (refreshLogsButton) {
          refreshLogsButton.addEventListener('click', refreshDebugLogs);
        }
        
        const clearLogsButton = document.getElementById('clearLogsButton');
        if (clearLogsButton) {
          clearLogsButton.addEventListener('click', clearDebugLogs);
        }
        
        const copyLogsButton = document.getElementById('copyLogsButton');
        if (copyLogsButton) {
          copyLogsButton.addEventListener('click', copyDebugLogs);
        }
        
        const debugButton = document.getElementById('debugButton');
        if (debugButton) {
          debugButton.addEventListener('click', testFirstComment);
        }
        
        // Refresh debug logs if debug section is visible
        if (userSettings.showDebugTools) {
          refreshDebugLogs();
        }
        
        // Load the Gemini API key if needed
        if (selectedModel && selectedModel.startsWith('gemini')) {
          loadGeminiApiKey();
        }
        
        // Initialize model dropdown visibility immediately
        toggleGeminiFields();
      }
      
      // Initialize the sidebar when the page loads
      window.onload = function() {
        // Set up sections and subsections first
        initSections();
        initSubsections();
        
        // Then initialize the rest of the sidebar
        initSidebar();
        
        // Try to restore state
        try {
          const savedState = sessionStorage.getItem('aiedit_state');
          if (savedState) {
            const state = JSON.parse(savedState);
            selectedModel = state.selectedModel || '';
            if (selectedModel) {
              document.getElementById('modelSelect').value = selectedModel;
            }
            // Check if sidebar was open
            if (state.isOpen) {
              reopenSidebarUI();
            }
          }
        } catch (error) {
          console.error('Error restoring state:', error);
        }
        
        // Initial UI setup based on selected edit mode
        updateEditModeUI();
      };
      
      // Cleanup function to handle any necessary cleanup when the sidebar is closed
      function cleanup() {
        try {
          // Save current state
          const state = {
            selectedModel: selectedModel || '',
            // Add other state variables as needed
          };
          
          sessionStorage.setItem('aiedit_state', JSON.stringify(state));
          
          // Cancel any pending operations if needed
          if (isProcessing) {
            // Attempt to cancel any ongoing processing
            console.log("Sidebar closing - cleaning up pending operations");
          }
        } catch (error) {
          console.error('Error during cleanup:', error);
        }
      }
      
      // Add cleanup handlers
      window.addEventListener('unload', cleanup);
      
      /**
       * Updates the UI based on which edit mode is selected (comments or document)
       */
      function updateEditModeUI() {
        const commentsMode = document.getElementById('comments-mode');
        const documentMode = document.getElementById('document-mode');
        const commentsContent = document.getElementById('comments-content');
        const documentContent = document.getElementById('document-content');
        
        if (commentsMode && documentMode && commentsContent && documentContent) {
          if (commentsMode.checked) {
            commentsContent.style.display = 'block';
            documentContent.style.display = 'none';
          } else if (documentMode.checked) {
            commentsContent.style.display = 'none';
            documentContent.style.display = 'block';
          }
        }
      }
      
      /**
       * Handles reopening the sidebar and restoring its state
       */
      function reopenSidebarUI() {
        // Update UI based on saved preferences
        const modelSelect = document.getElementById('modelSelect');
        if (modelSelect && selectedModel) {
          modelSelect.value = selectedModel;
          toggleGeminiFields();
        }
        
        // Refresh comment count
        if (google && google.script && google.script.run) {
          google.script.run
            .withSuccessHandler(function(comments) {
              const count = Array.isArray(comments) ? comments.length : 0;
              document.getElementById('commentCount').textContent = count;
              document.getElementById('processButton').disabled = count === 0;
            })
            .getAIComments();
        }
      }
      
      /**
       * Toggle visibility of Gemini API fields based on selected model
       */
      function toggleGeminiFields() {
        const geminiFields = document.querySelector('.gemini-api-fields');
        if (!geminiFields) return;
        
        // Show Gemini API key field only when a Gemini model is selected
        if (selectedModel && selectedModel.startsWith('gemini')) {
          geminiFields.style.display = 'block';
          
          // Load the API key if it's not already loaded
          const apiKeyInput = document.getElementById('geminiApiKey');
          if (apiKeyInput && !apiKeyInput.value) {
            loadGeminiApiKey();
          }
        } else {
          geminiFields.style.display = 'none';
        }
      }
      
      /**
       * Save the Gemini API key to server storage
       */
      function saveGeminiApiKey() {
        const apiKeyInput = document.getElementById('geminiApiKey');
        const apiKey = apiKeyInput.value.trim();
        
        if (!apiKey) {
          alert('Please enter a valid API key');
          return;
        }
        
        // Show a loading state
        const saveButton = document.getElementById('saveApiKey');
        const originalText = saveButton.textContent;
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';
        
        // Call the server to save the API key
        google.script.run
          .withSuccessHandler(function(success) {
            // Reset button state
            saveButton.disabled = false;
            
            if (success) {
              saveButton.textContent = 'Saved ✓';
              setTimeout(() => {
                saveButton.textContent = originalText;
              }, 2000);
            } else {
              alert('Failed to save API key');
              saveButton.textContent = originalText;
            }
          })
          .withFailureHandler(function(error) {
            // Reset button state
            saveButton.disabled = false;
            saveButton.textContent = originalText;
            
            alert('Error saving API key: ' + error);
          })
          .saveGeminiApiKey(apiKey);
      }
      
      /**
       * Load the Gemini API key from server storage
       */
      function loadGeminiApiKey() {
        google.script.run
          .withSuccessHandler(function(apiKey) {
            if (apiKey) {
              document.getElementById('geminiApiKey').value = apiKey;
            }
          })
          .withFailureHandler(function(error) {
            console.error('Failed to load API key:', error);
          })
          .getGeminiApiKey();
      }
      
      /**
       * Save all settings
       */
      function saveSettings() {
        // Get timeout value
        const timeoutInput = document.getElementById('timeoutSetting');
        const timeoutValue = parseInt(timeoutInput.value, 10);
        
        if (isNaN(timeoutValue) || timeoutValue < 30 || timeoutValue > 600) {
          alert('Please enter a valid timeout between 30 and 600 seconds');
          return;
        }
        
        // Get debug toggle state
        const debugToggle = document.getElementById('debug-toggle');
        const showDebugTools = debugToggle.checked;
        
        // Update settings object
        userSettings.timeout = timeoutValue * 1000; // Convert to milliseconds
        userSettings.showDebugTools = showDebugTools;
        userSettings.lastUpdate = new Date().toISOString();
        
        // Save settings
        google.script.run
          .withSuccessHandler(function() {
            const saveButton = document.getElementById('saveSettings');
            const originalText = saveButton.textContent;
            saveButton.textContent = 'Saved ✓';
            
            // Update debug info if visible
            if (showDebugTools) {
              document.getElementById('settingsDebugInfo').style.display = 'block';
              document.getElementById('lastSettingsUpdate').textContent = 
                new Date().toLocaleString();
              document.getElementById('currentModelDisplay').textContent = 
                selectedModel || 'None';
            }
            
            // Apply settings immediately
            toggleDebugSection(showDebugTools);
            
            setTimeout(() => {
              saveButton.textContent = originalText;
            }, 2000);
            
            // Log the settings update
            google.script.run.logDebug('state', 'Settings updated', userSettings);
          })
          .withFailureHandler(function(error) {
            alert('Failed to save settings: ' + error);
          })
          .saveUserSettings(JSON.stringify(userSettings));
      }
      
      /**
       * Toggle debug section visibility
       * @param {boolean} show - Whether to show or hide the debug section
       */
      function toggleDebugSection(show) {
        const debugSection = document.getElementById('debugSection');
        if (debugSection) {
          debugSection.style.display = show ? 'block' : 'none';
          
          // Also update the toggle to match
          const debugToggle = document.getElementById('debug-toggle');
          if (debugToggle) {
            debugToggle.checked = show;
          }
          
          // If showing debug section, refresh logs and scroll to it
          if (show) {
            // Add a small delay to ensure the UI has updated
            setTimeout(() => {
              refreshDebugLogs();
              debugSection.scrollIntoView({ behavior: 'smooth' });
            }, 100);
          }
        }
      }
      
      /**
       * Fetch available models from Ollama API
       * Populates the model selection dropdown
       */
      function fetchOllamaModels() {
        // Show loading state in dropdown
        const modelSelect = document.getElementById('modelSelect');
        if (!modelSelect) return;
        
        // Save current selection
        const currentSelection = modelSelect.value;
        
        // Clear dropdown except for Gemini option
        while (modelSelect.options.length > 0) {
          modelSelect.remove(0);
        }
        
        // Add loading option
        const loadingOption = document.createElement('option');
        loadingOption.value = '';
        loadingOption.text = 'Loading models...';
        modelSelect.add(loadingOption);
        
        // Add Gemini option
        const geminiOption = document.createElement('option');
        geminiOption.value = 'gemini-2.0-flash';
        geminiOption.text = 'Gemini 2.0 Flash';
        modelSelect.add(geminiOption);
        
        // Try to get local Ollama models
        try {
          // Fetch from Ollama API
          fetch('http://localhost:11434/api/tags', {
            method: 'GET',
          })
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            // Process models
            if (data && data.models && Array.isArray(data.models)) {
              // Sort models by name
              data.models.sort((a, b) => a.name.localeCompare(b.name));
              
              // Remove loading option
              modelSelect.remove(0);
              
              // Add each model to dropdown
              data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name;
                option.text = `${model.name} (Ollama)`;
                modelSelect.add(option);
              });
              
              // Restore previous selection if possible
              if (currentSelection) {
                for (let i = 0; i < modelSelect.options.length; i++) {
                  if (modelSelect.options[i].value === currentSelection) {
                    modelSelect.selectedIndex = i;
                    break;
                  }
                }
              } else if (userSettings && userSettings.selectedModel) {
                // Check for saved model preference in user settings
                for (let i = 0; i < modelSelect.options.length; i++) {
                  if (modelSelect.options[i].value === userSettings.selectedModel) {
                    modelSelect.selectedIndex = i;
                    break;
                  }
                }
              }
              
              // Update selected model variable
              selectedModel = modelSelect.value;
              toggleGeminiFields();
            }
          })
          .catch(error => {
            console.error('Error fetching Ollama models:', error);
            
            // Add default Ollama models as fallback
            const defaultModels = ['llama3', 'mistral', 'mixtral', 'phi3', 'qwen'];
            
            // Remove loading option
            modelSelect.remove(0);
            
            // Add each default model
            defaultModels.forEach(model => {
              const option = document.createElement('option');
              option.value = `${model}:latest`;
              option.text = `${model} (Ollama)`;
              modelSelect.add(option);
            });
            
            // Restore previous selection if possible
            if (currentSelection) {
              for (let i = 0; i < modelSelect.options.length; i++) {
                if (modelSelect.options[i].value === currentSelection) {
                  modelSelect.selectedIndex = i;
                  break;
                }
              }
            } else if (userSettings && userSettings.selectedModel) {
              // Check for saved model preference in user settings
              for (let i = 0; i < modelSelect.options.length; i++) {
                if (modelSelect.options[i].value === userSettings.selectedModel) {
                  modelSelect.selectedIndex = i;
                  break;
                }
              }
            }
            
            // Update selected model variable
            selectedModel = modelSelect.value;
            toggleGeminiFields();
          });
        } catch (error) {
          console.error('Error in fetchOllamaModels:', error);
        }
      }
      
      /**
       * Refresh debug logs from the server
       */
      function refreshDebugLogs() {
        const logsTextarea = document.getElementById('unifiedLogs');
        if (!logsTextarea) return;
        
        // Show loading state
        logsTextarea.value = 'Loading logs...';
        
        // Fetch logs from server
        if (google && google.script && google.script.run) {
          google.script.run
            .withSuccessHandler(function(logs) {
              if (!logs || logs === 'No logs available') {
                logsTextarea.value = 'No logs available';
                return;
              }
              
              try {
                // Process logs to make them more readable
                const processedLogs = logs
                  .split('\n')
                  .filter(line => line.trim().length > 0)
                  .map(line => {
                    try {
                      // Parse the JSON log entry if possible
                      const entry = JSON.parse(line);
                      if (entry && entry.timestamp && entry.category && entry.message) {
                        const timestamp = new Date(entry.timestamp).toLocaleTimeString();
                        const category = entry.category.toUpperCase();
                        const message = entry.message;
                        let dataStr = '';
                        
                        if (entry.data && Object.keys(entry.data).length > 0) {
                          dataStr = `\n  → ${JSON.stringify(entry.data, null, 2).replace(/\n/g, '\n  ')}`;
                        }
                        
                        // Add CSS class for formatting based on category
                        let categoryClass = '';
                        switch (entry.category) {
                          case 'error': categoryClass = 'log-error'; break;
                          case 'debug': categoryClass = 'log-debug'; break;
                          case 'comment': categoryClass = 'log-comment'; break;
                          case 'text': categoryClass = 'log-text'; break;
                          case 'state': categoryClass = 'log-state'; break;
                          default: categoryClass = '';
                        }
                        
                        return `[${timestamp}] [${category}] ${message}${dataStr}`;
                      }
                      return line;
                    } catch (e) {
                      // If not valid JSON, just return the raw line
                      return line;
                    }
                  })
                  .join('\n\n');
                
                logsTextarea.value = processedLogs || 'No logs available';
                
                // Log to console for debugging
                console.log('Loaded logs, characters:', processedLogs.length);
                
                // Scroll to bottom
                logsTextarea.scrollTop = logsTextarea.scrollHeight;
              } catch (error) {
                logsTextarea.value = 'Error processing logs: ' + error + '\n\nRaw logs:\n' + logs;
                console.error('Error processing logs:', error);
              }
            })
            .withFailureHandler(function(error) {
              logsTextarea.value = 'Failed to fetch logs: ' + error;
              console.error('Failed to fetch logs:', error);
            })
            .getDebugLogs();
        } else {
          logsTextarea.value = 'Cannot fetch logs: Script API not available';
        }
      }
      
      /**
       * Clear the debug logs display
       */
      function clearDebugLogs() {
        const logsTextarea = document.getElementById('unifiedLogs');
        if (logsTextarea) {
          logsTextarea.value = '';
        }
      }
      
      /**
       * Copy debug logs to clipboard
       */
      function copyDebugLogs() {
        const logsTextarea = document.getElementById('unifiedLogs');
        if (logsTextarea && logsTextarea.value) {
          // Select the text
          logsTextarea.select();
          
          try {
            // Copy it to clipboard
            document.execCommand('copy');
            
            // Show confirmation
            const copyButton = document.getElementById('copyLogsButton');
            if (copyButton) {
              const originalText = copyButton.innerHTML;
              copyButton.innerHTML = '<span class="copy-icon">✓</span> Copied';
              
              // Reset after 2 seconds
              setTimeout(() => {
                copyButton.innerHTML = originalText;
              }, 2000);
            }
          } catch (error) {
            console.error('Failed to copy logs:', error);
          }
          
          // Deselect
          window.getSelection().removeAllRanges();
        }
      }
      
      /**
       * Test processing the first AI comment for debugging purposes
       */
      function testFirstComment() {
        // Show loading state in debug log
        const logsTextarea = document.getElementById('unifiedLogs');
        if (logsTextarea) {
          logsTextarea.value += '\n\n[DEBUG] Testing first AI comment...';
          logsTextarea.scrollTop = logsTextarea.scrollHeight;
        }
        
        // Request the server to process just the first comment
        if (google && google.script && google.script.run) {
          google.script.run
            .withSuccessHandler(function(result) {
              if (logsTextarea) {
                logsTextarea.value += '\n[DEBUG] Test completed: ' + JSON.stringify(result, null, 2);
                logsTextarea.scrollTop = logsTextarea.scrollHeight;
              }
              refreshDebugLogs(); // Refresh logs to show all server-side logs
            })
            .withFailureHandler(function(error) {
              if (logsTextarea) {
                logsTextarea.value += '\n[ERROR] Test failed: ' + error;
                logsTextarea.scrollTop = logsTextarea.scrollHeight;
              }
            })
            .testProcessFirstComment(); // Call a server-side function
        }
      }

      // Format debug logs with category-based styling
      function formatDebugLogs(logs) {
        if (!logs) return '';
        
        return logs.split('\n').map(line => {
          try {
            const logEntry = JSON.parse(line);
            const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();
            const category = logEntry.category || 'text';
            const message = logEntry.message || '';
            
            // Add category-specific styling
            const categoryClass = `log-${category.toLowerCase()}`;
            
            // Special formatting for NUX-related logs
            if (message.includes('NUX') || message.includes('first time user')) {
              return `<span class="log-nux">[${timestamp}] ${message}</span>`;
            }
            
            return `<span class="${categoryClass}">[${timestamp}] ${message}</span>`;
          } catch (e) {
            return `<span class="log-text">${line}</span>`;
          }
        }).join('\n');
      }
      
      // Update debug info panel
      function updateDebugInfo() {
        google.script.run
          .withSuccessHandler(function(settings) {
            try {
              const userSettings = JSON.parse(settings);
              const lastReset = userSettings.lastNuxReset || 'Never';
              document.getElementById('lastNuxReset').textContent = lastReset;
              
              google.script.run
                .withSuccessHandler(function(isFirstTime) {
                  document.getElementById('firstTimeUserStatus').textContent = 
                    isFirstTime ? 'Yes' : 'No';
                })
                .checkFirstTimeUser();
            } catch (e) {
              console.error('Error updating debug info:', e);
            }
          })
          .getUserSettings();
      }
      
      // Update debug logs with formatting
      function updateDebugLogs() {
        google.script.run
          .withSuccessHandler(function(logs) {
            const formattedLogs = formatDebugLogs(logs);
            const logsElement = document.getElementById('debugLogs');
            logsElement.innerHTML = formattedLogs;
            
            // Auto-scroll to bottom
            logsElement.scrollTop = logsElement.scrollHeight;
          })
          .getDebugLogs();
      }
      
      // Show debug info panel in debug mode
      if (isDebugMode()) {
        document.getElementById('debugInfoPanel').style.display = 'block';
        updateDebugInfo();
      }
      
      // Update logs periodically
      setInterval(updateDebugLogs, 5000);
      
      // Initialize the Getting Started section
      function initGettingStarted() {
        const section = document.getElementById('getting-started-section');
        const header = document.getElementById('getting-started-header');
        
        if (section && header) {
          // Track when user expands/collapses the section
          header.addEventListener('click', () => {
            const isExpanding = !header.classList.contains('active');
            google.script.run
              .withSuccessHandler(() => {
                console.log('Logged Getting Started interaction');
              })
              .logDebug('nux', isExpanding ? 'Getting Started section expanded' : 'Getting Started section collapsed');
          });
          
          // Track when user interacts with help content
          const helpSteps = section.querySelectorAll('.help-step');
          helpSteps.forEach((step, index) => {
            step.addEventListener('click', () => {
              google.script.run
                .withSuccessHandler(() => {
                  console.log('Logged help step interaction');
                })
                .logDebug('nux', `User clicked help step ${index + 1}`);
            });
          });
          
          // Track when user interacts with tips
          const helpTips = section.querySelectorAll('.help-tip');
          helpTips.forEach((tip, index) => {
            tip.addEventListener('click', () => {
              google.script.run
                .withSuccessHandler(() => {
                  console.log('Logged help tip interaction');
                })
                .logDebug('nux', `User clicked help tip ${index + 1}`);
            });
          });
        }
      }
      
      // Call initGettingStarted after DOM is loaded
      document.addEventListener('DOMContentLoaded', initGettingStarted);
    </script>
  </body>
</html>
