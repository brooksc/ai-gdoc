<!DOCTYPE html>
<html>
<!-- Mon Feb 24 14:36:52 PST 2025 -->
  <head>
    <base target="_top">
    <meta charset="utf-8">
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 10px;
        color: #444;
      }
      h3 {
        color: #1a73e8;
        margin-bottom: 15px;
      }
      .container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .model-selector {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      .ai-comment-counter {
        background: #e8f0fe;
        border-radius: 4px;
        padding: 10px;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .counter-badge {
        background: #1a73e8;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }
      button {
        background-color: #1a73e8;
        color: white;
        border: none;
        padding: 10px 16px;
        font-size: 14px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: #1765cc;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }
      
      /* Logging section styles */
      .logging-section {
        margin-top: 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #fff;
      }
      
      .logging-header {
        display: flex;
        align-items: center;
        padding: 8px;
        background: #f8f9fa;
        border-bottom: 1px solid #ddd;
        border-radius: 4px 4px 0 0;
      }
      
      .logging-header h4 {
        margin: 0;
        flex-grow: 1;
        color: #1a73e8;
        font-size: 14px;
      }
      
      .copy-button, .clear-button, .refresh-button {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 8px;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
      }
      
      .copy-button:hover, .clear-button:hover, .refresh-button:hover {
        background: #f1f3f4;
      }
      
      .unified-logs {
        width: 100%;
        height: 300px;
        padding: 8px;
        font-family: 'Roboto Mono', monospace;
        font-size: 12px;
        border: none;
        resize: vertical;
        background: #fff;
        color: #444;
        line-height: 1.4;
        white-space: pre-wrap;
        overflow-y: auto;
      }
      
      .unified-logs:focus {
        outline: none;
        border-color: #1a73e8;
      }
      
      /* Add styles for different log categories */
      .log-error { color: #d93025; }
      .log-debug { color: #188038; }
      .log-comment { color: #1a73e8; }
      .log-text { color: #666; }
      .log-state { color: #9334e6; }
      

      .progress-container {
        margin-top: 15px;
      }
      .progress-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        font-size: 13px;
      }
      .current-processing {
        background: #fef7e0;
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 10px;
      }
      .current-processing h4 {
        margin: 0 0 8px 0;
        color: #b06000;
      }
      .text-block {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        margin: 4px 0;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
      }
      .revision-item {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 8px;
      }
      .revision-item h4 {
        margin: 0 0 8px 0;
        color: #188038;
      }
      .button-group {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }
      .accept-button {
        background-color: #188038;
      }
      .accept-button:hover {
        background-color: #137333;
      }
      .reject-button {
        background-color: #d93025;
      }
      .reject-button:hover {
        background-color: #c5221f;
      }
      .status {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 11px;
        margin-left: 5px;
      }
      .status-pending {
        background: #f1f3f4;
        color: #444;
      }
      .status-processing {
        background: #fef7e0;
        color: #b06000;
      }
      .status-completed {
        background: #e6f4ea;
        color: #137333;
      }
      .status-error {
        background: #fce8e6;
        color: #c5221f;
      }
      .refresh-models {
        font-size: 12px;
        color: #1a73e8;
        text-decoration: underline;
        cursor: pointer;
        margin-left: auto;
        border: none;
        background: none;
        padding: 0;
      }
      .cancel-button {
        background-color: #5f6368;
      }
      .cancel-button:hover {
        background-color: #494c50;
      }
      .processing-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 16px;
        z-index: 1000;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #1a73e8;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .diff-view {
        background: #f8f9fa;
        border-radius: 4px;
        padding: 8px;
        margin: 4px 0;
        font-family: monospace;
        font-size: 12px;
        white-space: pre-wrap;
      }
      .diff-removed {
        background: #fce8e6;
        text-decoration: line-through;
        color: #c5221f;
      }
      .diff-added {
        background: #e6f4ea;
        color: #137333;
      }
      .help-section {
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #eee;
      }
      
      /* Settings button and section styles */
      .settings-button {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 20px;
        color: #5f6368;
        background: none;
        border: none;
        cursor: pointer;
        font-size: 13px;
        padding: 8px;
        gap: 5px;
        width: 100%;
      }
      
      .settings-panel {
        display: none;
        margin-top: 10px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #eee;
      }
      
      .settings-panel.visible {
        display: block;
      }
      
      .toggle-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
      }
      
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
      }
      
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        border-radius: 10px;
        transition: .4s;
      }
      
      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        border-radius: 50%;
        transition: .4s;
      }
      
      input:checked + .toggle-slider {
        background-color: #1a73e8;
      }
      
      input:checked + .toggle-slider:before {
        transform: translateX(20px);
      }
      
      /* Document-wide prompt feature */
      .doc-prompt-container {
        margin-top: 20px;
        padding: 15px;
        background: #f0f7ff;
        border-radius: 4px;
        border: 1px solid #d0e3ff;
        display: block; /* Ensure it's visible */
      }
      
      .doc-prompt-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #1a73e8;
      }
      
      .prompt-textarea {
        width: 100%;
        min-height: 80px;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
        margin-bottom: 10px;
        resize: vertical;
      }
      
      .prompt-library-container {
        margin-bottom: 10px;
      }
      
      .prompt-library-select {
        width: 100%;
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
        margin-bottom: 5px;
      }
      
      .prompt-save-container {
        display: flex;
        margin-top: 5px;
        gap: 5px;
      }
      
      .prompt-save-input {
        flex-grow: 1;
        padding: 5px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      
      .prompt-save-button {
        background-color: #1a73e8;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .prompt-action-container {
        display: flex;
        justify-content: space-between;
        gap: 8px;
      }
      
      .prompt-submit-button {
        flex-grow: 1;
        background-color: #1a73e8;
      }
      
      .prompt-clear-button {
        background-color: #5f6368;
      }

      /* Debug section styles */
      .debug-section {
        display: none;
        margin-top: 20px;
      }
      
      .debug-section.visible {
        display: block;
      }
      
      /* Streaming response styles */
      .streaming-response {
        margin-top: 10px;
        margin-bottom: 10px;
      }
      
      .streaming-text {
        max-height: 150px;
        overflow-y: auto;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        padding: 8px;
        font-family: monospace;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }
    </style>
  </head>
  <body>
    <h3>AI Editor</h3>
    <div class="container">
      <div class="model-selector">
        <div style="display: flex; align-items: center;">
          <label for="modelSelect">Select Model:</label>
          <button class="refresh-models" id="refreshModels">Refresh</button>
        </div>
        <select id="modelSelect">
          <option value="">Loading models...</option>
        </select>
      </div>
      
      <!-- Document-wide prompt feature -->
      <div class="doc-prompt-container" style="display: block !important;">
        <div class="doc-prompt-title">Process Entire Document</div>
        
        <div class="prompt-library-container">
          <select id="promptLibrarySelect" class="prompt-library-select">
            <option value="">Select a prompt template...</option>
          </select>
          <div class="prompt-save-container">
            <input type="text" id="promptSaveName" class="prompt-save-input" placeholder="Name for this prompt">
            <button id="promptSaveButton" class="prompt-save-button">Save</button>
          </div>
        </div>
        
        <textarea id="docPromptInput" class="prompt-textarea" placeholder="Enter your prompt here..."></textarea>
        
        <div class="prompt-action-container">
          <button id="docPromptSubmit" class="prompt-submit-button">Process Document</button>
          <button id="docPromptClear" class="prompt-clear-button">Clear</button>
        </div>
      </div>
      
      <div class="ai-comment-counter">
        <span>Unprocessed AI Comments:</span>
        <span class="counter-badge" id="commentCount">0</span>
      </div>
      
      <button id="processButton" disabled>Generate Suggestions</button>
      
      <div class="progress-container">
        <div id="currentProcessing"></div>
        <div id="revisionsList"></div>
        <div id="progress"></div>
      </div>
      
      <!-- Main content ends -->
      
      <!-- How to use section -->
      <div class="help-section">
        <h3>How to use:</h3>
        <ol>
          <li>Highlight text you want to edit</li>
          <li>Add a comment starting with "AI:" followed by your instruction</li>
          <li>Click "Generate Suggestions" to process all AI comments</li>
          <li>Review and accept/reject each suggestion</li>
        </ol>
      </div>
      
      <!-- Settings button -->
      <button id="settingsButton" class="settings-button">
        <span id="settingsIcon">⚙️</span> Settings
      </button>
      
      <!-- Settings panel -->
      <div id="settingsPanel" class="settings-panel">
        <div class="toggle-row">
          <span>Show Debug Tools</span>
          <label class="toggle-switch">
            <input type="checkbox" id="debug-toggle">
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>
      
      <!-- Debug section -->
      <div id="debugSection" class="debug-section">
        <!-- Debug button -->
        <button id="debugButton" style="background-color: #ff9800; margin-bottom: 10px; width: 100%;">Debug: Test First Comment</button>
        
        <!-- Unified logging section -->
        <div class="logging-section" style="margin-bottom: 20px;">
          <div class="logging-header">
            <h4>Debug Logs</h4>
            <button id="copyLogsButton" class="copy-button" title="Copy logs to clipboard">
              <span class="copy-icon">📋</span> Copy
            </button>
            <button id="clearLogsButton" class="clear-button" title="Clear logs">
              <span class="clear-icon">🗑️</span> Clear
            </button>
            <button id="refreshLogsButton" class="refresh-button" title="Refresh logs">
              <span class="refresh-icon">🔄</span> Refresh
            </button>
          </div>
          <textarea id="unifiedLogs" readonly class="unified-logs" 
                    placeholder="Debug logs will appear here..."></textarea>
        </div>
      </div>
    </div>

    <div id="processingOverlay" class="processing-overlay" style="display: none;">
      <div class="spinner"></div>
      <div id="processingStatus">Processing...</div>
      <button class="cancel-button" onclick="cancelProcessing()">Cancel</button>
    </div>

    <script>
      // Global state
      let commentsList = [];
      let selectedModel = '';
      let isProcessing = false;
      let fileId = '';
      let currentComment = null;
      let isCancelled = false;
      let processingTimeout = null;
      let isApiCallInProgress = false;
      
      // Constants
      const TIMEOUT_MS = 300000; // 300 second timeout (5 minutes)
      
      // Initialize settings
      let userSettings = {
        showDebugTools: false,
        timeout: TIMEOUT_MS
      };
      
      // Define the prompt library with default prompts
      const promptLibrary = {
        DEFAULT_PROMPTS: [
          {
            name: "Improve Clarity",
            prompt: "Improve the clarity of this text while maintaining its original meaning. Make it more concise and easier to understand."
          },
          {
            name: "Fix Grammar & Spelling",
            prompt: "Correct any grammar, spelling, or punctuation errors in this text without changing its meaning."
          },
          {
            name: "Make More Formal",
            prompt: "Rewrite this text in a more formal and professional tone while preserving the original meaning."
          },
          {
            name: "Make More Casual",
            prompt: "Rewrite this text in a more casual and conversational tone while preserving the original meaning."
          },
          {
            name: "Strengthen Argument",
            prompt: "Strengthen the arguments in this text by adding more compelling evidence, logic, and persuasive language."
          },
          {
            name: "Simplify Language",
            prompt: "Simplify the language in this text to make it more accessible to a general audience. Aim for clarity and readability."
          },
          {
            name: "Add Examples",
            prompt: "Add relevant examples to illustrate the key points in this text, making the concepts more concrete and easier to understand."
          },
          {
            name: "Improve Structure",
            prompt: "Improve the structure and organization of this text to enhance flow and readability. Ensure logical progression of ideas."
          },
          {
            name: "Technical Review",
            prompt: "Review this technical content for accuracy, clarity, and completeness. Suggest improvements while maintaining technical precision."
          },
          {
            name: "Executive Summary",
            prompt: "Create a concise executive summary of this document, highlighting the most important points and conclusions."
          }
        ],
        savedPrompts: []
      };
      
      // Initialize the prompt library
      function initPromptLibrary() {
        // Ensure the document-wide prompt container is visible
        const docPromptContainer = document.querySelector('.doc-prompt-container');
        console.log('Document prompt container found:', !!docPromptContainer);
        if (docPromptContainer) {
          docPromptContainer.style.display = 'block';
          console.log('Made document prompt container visible');
        } else {
          console.error('Could not find document prompt container');
        }
        
        // Load saved prompts from server
        google.script.run
          .withSuccessHandler(function(promptsJson) {
            if (promptsJson) {
              try {
                const savedPrompts = JSON.parse(promptsJson);
                promptLibrary.savedPrompts = savedPrompts;
                console.log(`Loaded ${savedPrompts.length} saved prompts`);
              } catch (e) {
                console.error("Error parsing saved prompts:", e);
              }
            }
            
            // Populate the prompt dropdown
            populatePromptDropdown();
          })
          .withFailureHandler(function(error) {
            console.error("Failed to load prompt library:", error);
          })
          .getPromptLibrary();
        
        // Set up event listeners for prompt library
        document.getElementById('promptLibrarySelect').addEventListener('change', handlePromptSelect);
        document.getElementById('promptSaveButton').addEventListener('click', savePrompt);
        document.getElementById('docPromptSubmit').addEventListener('click', processDocumentWithPrompt);
        document.getElementById('docPromptClear').addEventListener('click', clearDocumentPrompt);
      }
      
      // Populate the prompt dropdown with default and saved prompts
      function populatePromptDropdown() {
        const select = document.getElementById('promptLibrarySelect');
        select.innerHTML = '<option value="">Select a prompt template...</option>';
        
        // Add default prompts group
        const defaultGroup = document.createElement('optgroup');
        defaultGroup.label = 'Default Prompts';
        
        promptLibrary.DEFAULT_PROMPTS.forEach(prompt => {
          const option = document.createElement('option');
          option.value = 'default:' + prompt.name;
          option.textContent = prompt.name;
          defaultGroup.appendChild(option);
        });
        
        select.appendChild(defaultGroup);
        
        // Add saved prompts group if any exist
        if (promptLibrary.savedPrompts && promptLibrary.savedPrompts.length > 0) {
          const savedGroup = document.createElement('optgroup');
          savedGroup.label = 'Your Saved Prompts';
          
          promptLibrary.savedPrompts.forEach(prompt => {
            const option = document.createElement('option');
            option.value = 'saved:' + prompt.name;
            option.textContent = prompt.name;
            savedGroup.appendChild(option);
          });
          
          select.appendChild(savedGroup);
        }
      }
      
      // Handle prompt selection from dropdown
      function handlePromptSelect(e) {
        const value = e.target.value;
        if (!value) return;
        
        const [type, name] = value.split(':');
        let selectedPrompt;
        
        if (type === 'default') {
          selectedPrompt = promptLibrary.DEFAULT_PROMPTS.find(p => p.name === name);
        } else if (type === 'saved') {
          selectedPrompt = promptLibrary.savedPrompts.find(p => p.name === name);
        }
        
        if (selectedPrompt) {
          document.getElementById('docPromptInput').value = selectedPrompt.prompt;
        }
      }
      
      // Save a new prompt to the library
      function savePrompt() {
        const nameInput = document.getElementById('promptSaveName');
        const promptInput = document.getElementById('docPromptInput');
        
        const name = nameInput.value.trim();
        const prompt = promptInput.value.trim();
        
        if (!name) {
          alert('Please enter a name for your prompt');
          return;
        }
        
        if (!prompt) {
          alert('Please enter a prompt');
          return;
        }
        
        // Check if name already exists
        const exists = promptLibrary.savedPrompts.some(p => p.name === name);
        if (exists) {
          if (!confirm(`A prompt named "${name}" already exists. Do you want to replace it?`)) {
            return;
          }
          // Remove the existing prompt with the same name
          promptLibrary.savedPrompts = promptLibrary.savedPrompts.filter(p => p.name !== name);
        }
        
        // Add the new prompt
        promptLibrary.savedPrompts.push({ name, prompt });
        
        // Save to server
        google.script.run
          .withSuccessHandler(function() {
            console.log('Prompt saved successfully');
            nameInput.value = '';
            populatePromptDropdown();
          })
          .withFailureHandler(function(error) {
            console.error('Failed to save prompt:', error);
            alert('Failed to save prompt: ' + error);
          })
          .savePromptLibrary(JSON.stringify(promptLibrary.savedPrompts));
      }
      
      // Process the entire document with the selected prompt
      function processDocumentWithPrompt() {
        const promptInput = document.getElementById('docPromptInput');
        const prompt = promptInput.value.trim();
        
        if (!prompt) {
          alert('Please enter a prompt');
          return;
        }
        
        if (!selectedModel) {
          alert('Please select a model');
          return;
        }
        
        if (isProcessing) {
          alert('Please wait for the current process to complete');
          return;
        }
        
        // Show processing overlay
        showProcessingOverlay('Retrieving document text...');
        isProcessing = true;
        updateProcessButtonState();
        
        // Get the document text as markdown
        google.script.run
          .withSuccessHandler(function(documentMarkdown) {
            if (!documentMarkdown) {
              hideProcessingOverlay();
              isProcessing = false;
              updateProcessButtonState();
              alert('Failed to retrieve document text');
              return;
            }
            
            // Create a progress container
            const progressElement = document.getElementById('progress');
            const sessionContainer = document.createElement('div');
            sessionContainer.className = 'progress-item';
            sessionContainer.style.marginBottom = '20px';
            
            const headerContainer = document.createElement('div');
            headerContainer.style.display = 'flex';
            headerContainer.style.alignItems = 'center';
            headerContainer.style.gap = '8px';
            
            const headerText = document.createElement('div');
            headerText.innerHTML = '<strong>Document Processing:</strong>';
            
            headerContainer.appendChild(headerText);
            sessionContainer.appendChild(headerContainer);
            
            // Add streaming container
            const streamingContainer = document.createElement('div');
            streamingContainer.className = 'streaming-response';
            streamingContainer.innerHTML = `
              <div>Processing document with prompt: "${escapeHtml(prompt.substring(0, 50) + (prompt.length > 50 ? '...' : ''))}"</div>
              <div class="streaming-text"></div>
            `;
            sessionContainer.appendChild(streamingContainer);
            
            progressElement.insertBefore(sessionContainer, progressElement.firstChild);
            
            // Update overlay
            showProcessingOverlay('Processing document with AI...');
            
            // Prepare the API request with formatting preservation instructions
            const apiUrl = 'http://localhost:11434/api/generate';
            const formattingInstructions = `
IMPORTANT: Your response MUST preserve the document's formatting structure. 
- Maintain all heading levels (# for H1, ## for H2, etc.)
- Preserve bullet points and numbered lists
- Keep paragraph structure
- Format your entire response in proper markdown
`;
            const requestBody = {
              model: selectedModel,
              prompt: `${formattingInstructions}\n\n${prompt}\n\nDocument content (in markdown format):\n${documentMarkdown}`,
              stream: true
            };
            
            // Create an AbortController for timeout
            const controller = new AbortController();
            const signal = controller.signal;
            
            // Use user's timeout setting if available, otherwise use default
            const timeoutToUse = userSettings.timeout || TIMEOUT_MS;
            
            // Set a timeout to abort the fetch after the specified time
            const timeoutId = setTimeout(() => {
              controller.abort();
              console.error(`API call timed out after ${timeoutToUse}ms`);
              
              streamingContainer.innerHTML += `
                <div class="progress-item status-error">
                  <strong>Error:</strong> Request timed out after ${timeoutToUse/1000} seconds.
                </div>
              `;
              
              hideProcessingOverlay();
              isProcessing = false;
              updateProcessButtonState();
            }, timeoutToUse);
            
            // Make the API request
            fetch(apiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(requestBody),
              signal: signal
            })
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
              }
              
              // Get a reader from the response body stream
              const reader = response.body.getReader();
              let accumulatedResponse = '';
              const streamingText = streamingContainer.querySelector('.streaming-text');
              
              // Function to process the stream
              function processStream() {
                return reader.read().then(({ done, value }) => {
                  // If the stream is done, process the final response
                  if (done) {
                    console.log('Stream complete');
                    clearTimeout(timeoutId);
                    
                    // Process the accumulated response
                    const sanitizedResponse = sanitizeResponse(accumulatedResponse);
                    
                    // Verify the text location
                    verifyTextLocation(currentComment, sanitizedResponse, commentsList.indexOf(currentComment));
                    return;
                  }
                  
                  // Convert the chunk to text
                  const chunk = new TextDecoder().decode(value);
                  
                  try {
                    // Process each line in the chunk
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                      if (line.trim() === '') continue;
                      
                      const data = JSON.parse(line);
                      if (data.response) {
                        accumulatedResponse += data.response;
                        
                        // Update the streaming text display
                        if (streamingText) {
                          streamingText.textContent = accumulatedResponse;
                          streamingText.scrollTop = streamingText.scrollHeight;
                        }
                      }
                    }
                  } catch (e) {
                    console.error('Error processing chunk:', e);
                  }
                  
                  // Continue processing the stream
                  return processStream();
                });
              }
              
              // Start processing the stream
              return processStream();
            })
            .catch(error => {
              clearTimeout(timeoutId);
              
              // Check if this was an abort error
              if (error.name === 'AbortError') {
                console.log('Fetch aborted due to timeout');
                return; // Already handled in the timeout callback
              }
              
              console.error('API call failed:', error);
              unifiedLogger.appendLog({
                message: 'API call failed',
                category: 'ERROR',
                timestamp: new Date().toISOString(),
                data: {
                  commentId: currentComment.id,
                  error: error.toString()
                }
              });
              
              // Update UI to show error
              if (streamingText) {
                streamingText.textContent = `Error: ${escapeHtml(error.toString())}`;
              }
              
              isApiCallInProgress = false;
              processNextComment(commentsList.indexOf(currentComment) + 1);
            });
          })
          .withFailureHandler(function(error) {
            hideProcessingOverlay();
            isProcessing = false;
            updateProcessButtonState();
            alert('Failed to retrieve document text: ' + error);
          })
          .getDocumentAsMarkdown();
      }
      
      // Append the AI response to the document
      function appendResponseToDocument(response) {
        const progressElement = document.getElementById('progress');
        
        // Show processing overlay
        showProcessingOverlay('Appending response to document...');
        
        // Ensure the response is properly formatted as markdown
        // If the response doesn't start with markdown formatting, add it
        let formattedResponse = response.trim();
        
        // Check if the response contains proper markdown headings
        const hasMarkdownHeadings = /^#+\s+.+$/m.test(formattedResponse);
        if (!hasMarkdownHeadings) {
          // Add basic markdown formatting if it's missing
          console.log('Adding markdown formatting to response');
          
          // Split into paragraphs
          const paragraphs = formattedResponse.split(/\n{2,}/);
          formattedResponse = '';
          
          // Process each paragraph
          for (let i = 0; i < paragraphs.length; i++) {
            const para = paragraphs[i].trim();
            if (!para) continue;
            
            // Check if it looks like a heading (all caps, short line, ends with colon)
            if (para.toUpperCase() === para && para.length < 50 && para.endsWith(':')) {
              formattedResponse += '## ' + para + '\n\n';
            } 
            // Check if it looks like a subheading (ends with colon)
            else if (para.endsWith(':') && para.length < 100) {
              formattedResponse += '### ' + para + '\n\n';
            }
            // Check for bullet points
            else if (para.startsWith('•') || para.startsWith('*') || para.startsWith('-')) {
              formattedResponse += para + '\n\n';
            }
            // Regular paragraph
            else {
              formattedResponse += para + '\n\n';
            }
          }
        }
        
        google.script.run
          .withSuccessHandler(function() {
            hideProcessingOverlay();
            isProcessing = false;
            updateProcessButtonState();
            
            // Add success message
            const successMessage = document.createElement('div');
            successMessage.className = 'progress-item status-completed';
            successMessage.innerHTML = '<strong>Success:</strong> AI response added to the end of the document';
            progressElement.insertBefore(successMessage, progressElement.firstChild);
          })
          .withFailureHandler(function(error) {
            hideProcessingOverlay();
            isProcessing = false;
            updateProcessButtonState();
            
            // Add error message
            const errorMessage = document.createElement('div');
            errorMessage.className = 'progress-item status-error';
            errorMessage.innerHTML = `<strong>Error:</strong> ${escapeHtml(error.toString())}`;
            progressElement.insertBefore(errorMessage, progressElement.firstChild);
          })
          .appendToDocument(formattedResponse);
      }
      
      // Clear the document prompt input
      function clearDocumentPrompt() {
        document.getElementById('docPromptInput').value = '';
        document.getElementById('promptLibrarySelect').selectedIndex = 0;
      }
      
      // Load settings on startup
      function loadUserSettings() {
        google.script.run
          .withSuccessHandler(function(settings) {
            if (settings) {
              try {
                // Server returns already parsed JSON object
                userSettings = { ...userSettings, ...settings };
                
                // Apply settings
                if (userSettings.showDebugTools) {
                  document.getElementById('debug-toggle').checked = true;
                  document.getElementById('debugSection').classList.add('visible');
                } else {
                  document.getElementById('debug-toggle').checked = false;
                  document.getElementById('debugSection').classList.remove('visible');
                }
                
                // Update timeout if it was changed
                if (userSettings.timeout && userSettings.timeout !== TIMEOUT_MS) {
                  console.log(`Loaded custom timeout: ${userSettings.timeout}ms`);
                }
              } catch (e) {
                console.error("Error applying settings:", e);
              }
            }
          })
          .withFailureHandler(function(error) {
            console.error("Failed to load settings:", error);
          })
          .getSettings();
      }

      // Save settings when changed
      function saveUserSettings() {
        try {
          const settingsJson = JSON.stringify(userSettings);
        google.script.run
          .withSuccessHandler(function() {
              console.log("Settings saved successfully");
          })
          .withFailureHandler(function(error) {
              console.error("Failed to save settings:", error);
            })
            .saveSettings(settingsJson);
        } catch (e) {
          console.error("Error saving settings:", e);
        }
      }

      // Toggle debug tools visibility
      document.getElementById('debug-toggle').addEventListener('change', function(e) {
        const debugSection = document.getElementById('debugSection');
        userSettings.showDebugTools = e.target.checked;
        
        if (e.target.checked) {
          debugSection.classList.add('visible');
        } else {
          debugSection.classList.remove('visible');
        }
        
        saveUserSettings();
      });

      // Call loadSettings on startup
      document.addEventListener('DOMContentLoaded', function() {
        // Ensure debug section is hidden by default
        document.getElementById('debugSection').classList.remove('visible');
        document.getElementById('debug-toggle').checked = false;
        
        // Then load user settings which may override this
        loadUserSettings();
        initPromptLibrary();
        
        // Initialize settings button
        document.getElementById('settingsButton').addEventListener('click', toggleSettingsPanel);
      });
      
      // Toggle settings panel visibility
      function toggleSettingsPanel() {
        const settingsPanel = document.getElementById('settingsPanel');
        settingsPanel.classList.toggle('visible');
        
        // Update button icon
        const settingsIcon = document.getElementById('settingsIcon');
        if (settingsPanel.classList.contains('visible')) {
          settingsIcon.textContent = '✖️';
        } else {
          settingsIcon.textContent = '⚙️';
        }
      }
      
      /**
       * Handle errors in a user-friendly way
       */
      function handleError(error) {
        const errorMessage = error.toString();
        
        // Log the error
        unifiedLogger.appendLog({
          message: 'Error: ' + errorMessage,
          category: 'ERROR',
          timestamp: new Date().toISOString(),
          data: error
        });
        
        // Update progress UI
        const progressElement = document.getElementById('progress');
        progressElement.innerHTML = `<div class="progress-item status-error">Error: ${escapeHtml(errorMessage)}</div>`;
        
        // Reset state
        isProcessing = false;
        isApiCallInProgress = false;
        currentComment = null;
        
        // Update UI
        updateProcessButtonState();
        hideProcessingOverlay();
        displayCurrentProcessing(null);
      }
      
      // Handle page visibility changes
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          // Save state before page becomes hidden
          try {
            const state = {
              selectedModel,
              isProcessing,
              currentComment,
              commentsList,
              isOpen: true // Add isOpen flag
            };
            sessionStorage.setItem('aiedit_state', JSON.stringify(state));
          } catch (e) {
            console.error('Error saving state:', e);
            unifiedLogger.appendLog({
              message: 'Error saving state',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: e.toString() }
            });
          }
        } else {
          // Page is visible again, check if we need to restore state
          try {
            const savedState = sessionStorage.getItem('aiedit_state');
            if (savedState) {
              const state = JSON.parse(savedState);
              
              // Restore only safe state
              selectedModel = state.selectedModel || '';
              commentsList = state.commentsList || [];
              
              // Reset processing state for safety
              isProcessing = false;
              currentComment = null;
              isCancelled = false;
              isApiCallInProgress = false;
              
              // Update UI
              updateProcessButtonState();
              displayCurrentProcessing(null);
              hideProcessingOverlay();
              
              // Refresh data if sidebar was open
              if (state.isOpen) {
                reopenSidebarUI();
              }
            }
          } catch (e) {
            console.error('Error restoring state:', e);
            unifiedLogger.appendLog({
              message: 'Error restoring state',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: e.toString() }
            });
            // On error, do a clean reload
            cleanup();
            initSidebar();
          }
        }
      });
      
      // Handle beforeunload
      window.addEventListener('beforeunload', function(e) {
        if (isProcessing) {
          // Warn user if processing is ongoing
          e.preventDefault();
          e.returnValue = 'Changes you made may not be saved. Are you sure you want to leave?';
          return e.returnValue;
        }
      });
      
      /**
       * Clean up function for page unload
       */
      function cleanup() {
        if (processingTimeout) {
          clearTimeout(processingTimeout);
          processingTimeout = null;
        }
        
        // Clear state
        isCancelled = true;
        isProcessing = false;
        isApiCallInProgress = false;
        currentComment = null;
        
        // Clear storage
        try {
          sessionStorage.removeItem('aiedit_state');
        } catch (e) {
          console.error('Error clearing state:', e);
          unifiedLogger.appendLog({
            message: 'Error clearing state',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { error: e.toString() }
          });
        }
        
        // Reset UI
        displayCurrentProcessing(null);
          hideProcessingOverlay();
          updateProcessButtonState();
      }

      /**
       * Function to handle reopening the sidebar UI
       */
      function reopenSidebarUI() {
        fetchComments(); // Refresh comments
        fetchModels(); // Refresh models
        updateProcessButtonState(); // Update button state
      }

      // Initialize the sidebar when the page loads
      window.onload = function() {
        initSidebar();
        
        // Try to restore state
        try {
          const savedState = sessionStorage.getItem('aiedit_state');
          if (savedState) {
            const state = JSON.parse(savedState);
            selectedModel = state.selectedModel || '';
            if (selectedModel) {
              document.getElementById('modelSelect').value = selectedModel;
            }
            // Check if sidebar was open
            if (state.isOpen) {
              reopenSidebarUI();
            }
          }
        } catch (e) {
          console.error('Error restoring initial state:', e);
          unifiedLogger.appendLog({
            message: 'Error restoring initial state',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { error: e.toString() }
          });
        }
        
        // Add cleanup handlers
        window.addEventListener('unload', cleanup);
        
        // Add event delegation for retry buttons
        document.addEventListener('click', function(e) {
          if (e.target && e.target.classList.contains('retry-button')) {
            const index = parseInt(e.target.dataset.index, 10);
            if (!isNaN(index) && index >= 0 && index < commentsList.length) {
              // Clear the current processing element
              const currentProcessing = document.getElementById(`processing-${index}`);
              if (currentProcessing) {
                currentProcessing.innerHTML = '<div>Retrying...</div>';
              }
              
              // Reset API call lock
              isApiCallInProgress = false;
              
              // Process the comment again
              processNextComment(index);
            }
          }
        });
      };
      
      // Debounce function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      // Create debounced version of fetchModels
      const debouncedFetchModels = debounce(fetchModels, 1000);
      
      /**
       * Initialize the sidebar
       */
      function initSidebar() {
        document.getElementById('refreshModels').addEventListener('click', debouncedFetchModels);
        document.getElementById('processButton').addEventListener('click', processAIComments);
        document.getElementById('modelSelect').addEventListener('change', handleModelChange);
        
        // Load user settings
        loadUserSettings();
        
        // Load saved model from server
                    google.script.run
          .withSuccessHandler(function(savedModel) {
            if (savedModel) {
              selectedModel = savedModel;
              console.log('Loaded saved model from server:', savedModel);
            }
                      })
                      .withFailureHandler(function(error) {
            console.error('Failed to load saved model:', error);
          })
          .getSelectedModel();
        
        // Get fileId first
        google.script.run
          .withSuccessHandler(function(id) {
            fileId = id;
            // Initial data loading
            fetchComments();
            fetchModels();
          })
          .withFailureHandler(handleError)
          .getDocumentId();
      }
      
      /**
       * Fetch AI comments from the document
       */
      function fetchComments() {
        document.getElementById('progress').innerHTML = '<div class="progress-item">Fetching AI comments...</div>';
        
        google.script.run
          .withSuccessHandler(updateCommentsList)
          .withFailureHandler(handleError)
          .getAIComments();
      }
      
      /**
       * Update the UI with fetched comments
       */
      function updateCommentsList(comments) {
        if (!comments) {
          handleError("Failed to retrieve comments");
          return;
        }

        commentsList = comments;
        document.getElementById('commentCount').textContent = String(comments.length);
        
        const progressElement = document.getElementById('progress');
        if (comments.length === 0) {
          progressElement.innerHTML = [
            '<div class="progress-item">No unprocessed AI comments found.</div>',
            '<div class="progress-item"><b>How to use:</b></div>',
            '<div class="progress-item">1. Highlight text you want to edit</div>',
            '<div class="progress-item">2. Add a comment starting with "AI:" followed by your instruction</div>',
            '<div class="progress-item">3. Click "Generate Suggestions" to get AI edits</div>',
            '<div class="progress-item">4. Review and accept/reject suggestions</div>',
            '<button id="refreshButton" style="margin-top: 10px; width: 100%;">Refresh Comments</button>'
          ].join('');
          
          // Clean up old event listener if it exists
          const oldButton = document.getElementById('refreshButton');
          const newButton = oldButton.cloneNode(true);
          oldButton.parentNode.replaceChild(newButton, oldButton);
          newButton.addEventListener('click', fetchComments);
        } else {
          progressElement.innerHTML = '<div class="progress-item">Found ' + comments.length + ' unprocessed AI comments ready for processing.</div>';
        }
        
        updateProcessButtonState();
      }
      
      /**
       * Escape HTML to prevent XSS
       */
      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
      
      /**
       * Display the currently processing comment
       */
      function displayCurrentProcessing(comment) {
        const container = document.getElementById('currentProcessing');
        if (!comment) {
          container.innerHTML = '';
          return;
        }
        
        container.innerHTML = `
          <div class="current-processing">
            <h4>Currently Processing:</h4>
            <div><strong>Instruction:</strong></div>
            <div class="text-block">${escapeHtml(comment.instruction)}</div>
            <div><strong>Original Text:</strong></div>
            <div class="text-block">${escapeHtml(comment.text)}</div>
          </div>
        `;
      }
      
      /**
       * Show processing overlay
       */
      function showProcessingOverlay(message) {
        const overlay = document.getElementById('processingOverlay');
        document.getElementById('processingStatus').textContent = message || 'Processing...';
        overlay.style.display = 'flex';
      }
      
      /**
       * Hide processing overlay
       */
      function hideProcessingOverlay() {
        document.getElementById('processingOverlay').style.display = 'none';
      }
      
      /**
       * Cancel ongoing processing
       */
      function cancelProcessing() {
          isCancelled = true;
        if (processingTimeout) {
          clearTimeout(processingTimeout);
          processingTimeout = null;
        }
          isProcessing = false;
        currentComment = null;
        displayCurrentProcessing(null);
          updateProcessButtonState();
          hideProcessingOverlay();
        document.getElementById('progress').innerHTML = 
          '<div class="progress-item">Processing cancelled by user.</div>';
      }
      
      /**
       * Show diff between original and suggested text
       */
      function createDiffView(originalText, suggestedText) {
        return `
          <div class="diff-view">
            <div class="diff-removed">${escapeHtml(originalText)}</div>
            <div class="diff-added">${escapeHtml(suggestedText)}</div>
          </div>
        `;
      }
      
      /**
       * Add a revision to the list
       */
      function addRevision(comment, suggestedText) {
        const container = document.getElementById('revisionsList');
        const revisionElement = document.createElement('div');
        revisionElement.className = 'revision-item';
        revisionElement.id = 'revision-' + comment.id;
        
        // Create the content container first
        const contentContainer = document.createElement('div');
        contentContainer.innerHTML = `
          <h4>Suggested Edit:</h4>
          <div><strong>Instruction:</strong></div>
          <div class="text-block">${escapeHtml(comment.instruction)}</div>
          <div><strong>Changes:</strong></div>
          ${createDiffView(comment.text, suggestedText)}
        `;
        revisionElement.appendChild(contentContainer);
        
        // Create accept and reject buttons separately
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'button-group';
        
        const acceptButton = document.createElement('button');
        acceptButton.className = 'accept-button';
        acceptButton.textContent = 'Accept';
        acceptButton.addEventListener('click', () => handleAccept(comment.id, suggestedText));
        
        const rejectButton = document.createElement('button');
        rejectButton.className = 'reject-button';
        rejectButton.textContent = 'Reject';
        rejectButton.addEventListener('click', () => handleReject(comment.id, suggestedText));
        
        buttonGroup.appendChild(acceptButton);
        buttonGroup.appendChild(rejectButton);
        revisionElement.appendChild(buttonGroup);
        
        container.insertBefore(revisionElement, container.firstChild);
      }
      
      /**
       * Handle accepting a suggestion
       */
      function handleAccept(commentId, suggestedText) {
        const revisionElement = document.getElementById('revision-' + commentId);
        if (!revisionElement) return;

        unifiedLogger.appendLog({
          message: 'Starting accept operation',
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: {
            commentId: commentId,
            suggestedTextLength: suggestedText.length,
            fileId: fileId
          }
        });

        revisionElement.querySelector('.button-group').innerHTML = '<div class="status status-processing">Applying changes...</div>';

        google.script.run
          .withSuccessHandler(function() {
            unifiedLogger.appendLog({
              message: 'Changes applied successfully',
              category: 'DEBUG',
              timestamp: new Date().toISOString(),
              data: { commentId: commentId }
            });
            revisionElement.innerHTML = '<div class="status status-completed">Changes applied successfully</div>';
            setTimeout(() => {
              revisionElement.remove();
              fetchComments(); // Refresh comment list
            }, 2000);
          })
          .withFailureHandler(function(error) {
            unifiedLogger.appendLog({
              message: 'Failed to apply changes',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: {
                commentId: commentId,
                error: error.toString()
              }
            });
            
            const escapedError = escapeHtml(error.toString());
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            buttonGroup.innerHTML = `
              <div class="status status-error">Error: ${escapedError}</div>
              <div class="button-group">
                <button class="accept-button">Retry Accept</button>
                <button class="reject-button">Reject Instead</button>
              </div>`;
            
            const oldButtonGroup = revisionElement.querySelector('.button-group');
            oldButtonGroup.replaceWith(buttonGroup);
            
            // Add event listeners for retry/reject
            const retryButton = buttonGroup.querySelector('.accept-button');
            const rejectButton = buttonGroup.querySelector('.reject-button');
            retryButton.addEventListener('click', () => handleAccept(commentId, suggestedText));
            rejectButton.addEventListener('click', () => handleReject(commentId, suggestedText));
          })
          .applyAIEdit(fileId, commentId, suggestedText, true);
      }
      
      /**
       * Handle rejecting a suggestion
       */
      function handleReject(commentId, suggestedText) {
        const revisionElement = document.getElementById('revision-' + commentId);
        if (!revisionElement) return;
        
        unifiedLogger.appendLog({
          message: 'Starting reject operation',
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: {
            commentId: commentId,
            suggestedTextLength: suggestedText.length,
            fileId: fileId
          }
        });
        
        revisionElement.querySelector('.button-group').innerHTML = '<div class="status status-processing">Rejecting suggestion...</div>';
        
        google.script.run
          .withSuccessHandler(function() {
            unifiedLogger.appendLog({
              message: 'Changes rejected successfully',
              category: 'DEBUG',
              timestamp: new Date().toISOString()
            });
            revisionElement.innerHTML = '<div class="status status-completed">Suggestion rejected</div>';
            setTimeout(() => {
              revisionElement.remove();
              fetchComments(); // Refresh comment list
            }, 2000);
          })
          .withFailureHandler(function(error) {
            unifiedLogger.appendLog({
              message: 'Failed to reject changes',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: error.toString() }
            });
            
            const escapedError = escapeHtml(error.toString());
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            buttonGroup.innerHTML = `
              <div class="status status-error">Error: ${escapedError}</div>
              <div class="button-group">
                <button class="reject-button">Retry Reject</button>
                <button class="accept-button">Accept Instead</button>
              </div>`;
            
            const oldButtonGroup = revisionElement.querySelector('.button-group');
            oldButtonGroup.replaceWith(buttonGroup);
            
            // Add event listeners for retry/reject
            const retryButton = buttonGroup.querySelector('.reject-button');
            const acceptButton = buttonGroup.querySelector('.accept-button');
            retryButton.addEventListener('click', () => handleReject(commentId, suggestedText));
            acceptButton.addEventListener('click', () => handleAccept(commentId, suggestedText));
          })
          .applyAIEdit(fileId, commentId, suggestedText, false);
      }
      
      /**
       * Populate the model dropdown with available models
       */
      function fetchModels() {
        const modelSelect = document.getElementById('modelSelect');
        modelSelect.innerHTML = '<option value="">Loading models...</option>';
        modelSelect.disabled = true;

        fetch('http://localhost:11434/api/tags', {
          mode: 'cors',
          headers: {
            'Accept': 'application/json'
          }
        })
        .then(function(response) {
          if (!response.ok) {
            throw new Error('Failed to fetch models: ' + response.statusText);
          }
          return response.json();
        })
        .then(function(data) {
          modelSelect.disabled = false;
          if (data && data.models) {
            modelSelect.innerHTML = '';
            if (!data.models || data.models.length === 0) {
              modelSelect.innerHTML = '<option value="">No models available</option>';
          return;
        }
            modelSelect.appendChild(new Option('Select a model...', ''));

            data.models.forEach(function(model) {
              const option = new Option(model.name, model.name);
              if (model.name === selectedModel) {
                option.selected = true;
              }
              modelSelect.appendChild(option);
            });
            updateProcessButtonState();
          } else {
            throw new Error('Invalid response from Ollama API');
          }
        })
        .catch(function(error) {
          console.error('Error fetching models:', error);
          unifiedLogger.appendLog({
            message: 'Error fetching models',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { error: error.toString() }
          });
          modelSelect.disabled = false;
          modelSelect.innerHTML =
            '<option value="">Error: Cannot connect to Ollama</option>' +
            '<option value="" disabled>Make sure Ollama is running on port 11434</option>';
        });
      }
      
      /**
       * Handle model selection change
       */
      function handleModelChange(e) {
        selectedModel = e.target.value;
        updateProcessButtonState();
        
        // Save the selected model
        google.script.run
          .withFailureHandler(function(error) {
            console.error('Failed to save model selection:', error);
            unifiedLogger.appendLog({
              message: 'Failed to save model selection',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: error.toString() }
            });
          })
          .saveSelectedModel(selectedModel);
      }
      
      /**
       * Update process button enabled/disabled state
       */
      function updateProcessButtonState() {
        const button = document.getElementById('processButton');
        button.disabled = isProcessing || commentsList.length === 0 || !selectedModel;
      }
      
      /**
       * Copy session logs to clipboard
       */
      function copySessionLogs(container) {
        const logText = Array.from(container.querySelectorAll('div'))
          .slice(1) // Skip the header div
          .map(div => div.textContent)
          .join('\n');
        
        navigator.clipboard.writeText(logText).then(
          () => {
            const btn = container.querySelector('button');
            const originalText = btn.textContent;
            btn.textContent = '✓';
            setTimeout(() => {
              btn.textContent = originalText;
            }, 1000);
          },
          (err) => {
            console.error('Failed to copy logs:', err);
            const btn = container.querySelector('button');
            btn.textContent = '✗';
            setTimeout(() => {
              btn.textContent = '📋';
            }, 1000);
          }
        );
      }
      
      /**
       * Process all AI comments sequentially
       */
      function processAIComments() {
        if (isProcessing || commentsList.length === 0 || !selectedModel) {
          return;
        }
        
        // Create a new container for this processing session's logs
        const progressElement = document.getElementById('progress');
        const sessionContainer = document.createElement('div');
        sessionContainer.className = 'progress-item';
        sessionContainer.style.marginBottom = '20px';
        
        const headerContainer = document.createElement('div');
        headerContainer.style.display = 'flex';
        headerContainer.style.alignItems = 'center';
        headerContainer.style.gap = '8px';
        
        const headerText = document.createElement('div');
        headerText.innerHTML = '<strong>Processing Session Logs:</strong>';
        
        const copyButton = document.createElement('button');
        copyButton.style.padding = '4px 8px';
        copyButton.style.fontSize = '12px';
        copyButton.style.minWidth = '32px';
        copyButton.title = 'Copy logs to clipboard';
        copyButton.textContent = '📋';
        copyButton.addEventListener('click', () => copySessionLogs(sessionContainer));
        
        headerContainer.appendChild(headerText);
        headerContainer.appendChild(copyButton);
        sessionContainer.appendChild(headerContainer);
        
        progressElement.insertBefore(sessionContainer, progressElement.firstChild);
        
        // Don't clear revisionsList anymore
        isCancelled = false;
        isProcessing = true;
        isApiCallInProgress = false;  // Reset API call lock
        updateProcessButtonState();
        showProcessingOverlay('Preparing to process comments...');
        
        // Start processing after a short delay
        processingTimeout = setTimeout(() => processNextComment(0, sessionContainer), 500);
      }
      
      /**
       * Process comments one by one
       */
      function processNextComment(index) {
        if (isCancelled || index >= commentsList.length || isApiCallInProgress) {
          if (!isApiCallInProgress) {
            isProcessing = false;
            currentComment = null;
            displayCurrentProcessing(null);
            updateProcessButtonState();
            hideProcessingOverlay();
            
            if (!isCancelled && index > 0) {
              unifiedLogger.appendLog({
                message: 'Finished processing all comments',
                category: 'DEBUG',
                timestamp: new Date().toISOString()
              });
            }
          }
          return;
        }
        
        currentComment = commentsList[index];
        displayCurrentProcessing(currentComment);
        showProcessingOverlay(`Processing comment ${index + 1} of ${commentsList.length}...`);
        
        const prompt = currentComment.instruction + '\n\nText to edit:\n' + currentComment.text + 
                      '\n\nPlease provide only the edited text without any explanations or formatting:';
        
        // Add delay between API calls
        processingTimeout = setTimeout(() => callOllamaAPI(currentComment, prompt, index), 1000);
      }
      
      /**
       * Debug function to test comment processing
       */
      function debugFirstComment() {
        const debugButton = document.getElementById('debugButton');
        debugButton.disabled = true;
        debugButton.textContent = 'Testing...';
        
        unifiedLogger.appendLog({
          message: 'Starting debug test',
          category: 'DEBUG',
          timestamp: new Date().toISOString()
        });

        // Get first comment
        google.script.run
          .withSuccessHandler(function(comments) {
            if (!comments || comments.length === 0) {
              unifiedLogger.appendLog({
                message: 'No comments found',
                category: 'DEBUG',
                timestamp: new Date().toISOString()
              });
              debugButton.textContent = 'No Comments ✗';
              setTimeout(() => {
                debugButton.disabled = false;
                debugButton.textContent = 'Debug: Test First Comment';
              }, 2000);
              return;
            }

            const comment = comments[0];
            unifiedLogger.appendLog({
              message: 'Found first comment',
              category: 'DEBUG',
              timestamp: new Date().toISOString(),
              data: comment
            });

            // Simulate API response
            const simulatedResponse = "It works!!";
            unifiedLogger.appendLog({
              message: 'Simulated API response',
              category: 'DEBUG',
              timestamp: new Date().toISOString(),
              data: { response: simulatedResponse }
            });

            // Verify text location
            google.script.run
              .withSuccessHandler(function(result) {
                if (!result || !result.success) {
                  unifiedLogger.appendLog({
                    message: 'Text location verification failed',
                    category: 'ERROR',
                    timestamp: new Date().toISOString(),
                    data: result
                  });
                  throw new Error(result.error || 'Could not verify text location');
                }

                unifiedLogger.appendLog({
                  message: 'Text location verified successfully',
                  category: 'DEBUG',
                  timestamp: new Date().toISOString(),
                  data: {
                    commentId: comment.id,
                    suggestedTextLength: simulatedResponse.length
                  }
                });

                // Add the suggestion to the UI for user review
                addRevision(comment, simulatedResponse);
                
                debugButton.textContent = 'Test Completed ✓';
                setTimeout(() => {
                  debugButton.disabled = false;
                  debugButton.textContent = 'Debug: Test First Comment';
                }, 2000);
              })
              .withFailureHandler(function(error) {
                unifiedLogger.appendLog({
                  message: 'Text location verification failed',
                  category: 'ERROR',
                  timestamp: new Date().toISOString(),
                  data: { error: error.toString() }
                });
                debugButton.textContent = 'Test Failed ✗';
                debugButton.style.backgroundColor = '#d93025';
                setTimeout(() => {
                  debugButton.disabled = false;
                  debugButton.textContent = 'Debug: Test First Comment';
                  debugButton.style.backgroundColor = '#ff9800';
                }, 2000);
              })
              .verifyTextLocation(fileId, comment.id, comment.text);
          })
          .withFailureHandler(function(error) {
            unifiedLogger.appendLog({
              message: 'Failed to get comments',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: error.toString() }
            });
            debugButton.textContent = 'Test Failed ✗';
            debugButton.style.backgroundColor = '#d93025';
            setTimeout(() => {
              debugButton.disabled = false;
              debugButton.textContent = 'Debug: Test First Comment';
              debugButton.style.backgroundColor = '#ff9800';
            }, 2000);
          })
          .getAIComments();
      }

      // Add debug button handler
      document.getElementById('debugButton').addEventListener('click', debugFirstComment);

      /**
       * Call Ollama API to process a comment
       */
      function callOllamaAPI(comment, prompt, currentIndex) {
        // Create an AbortController for timeout
        const controller = new AbortController();
        const signal = controller.signal;
        
        // Use user's timeout setting if available, otherwise use default
        const timeoutToUse = userSettings.timeout || TIMEOUT_MS;
        
        // Set a timeout to abort the fetch after the specified time
        const timeoutId = setTimeout(() => {
          controller.abort();
          console.error(`API call timed out after ${timeoutToUse}ms`);
          unifiedLogger.appendLog({
            message: `API call timed out after ${timeoutToUse}ms`,
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { commentId: comment.id }
          });
          
          // Update UI to show timeout error
          const currentProcessing = document.getElementById(`processing-${currentIndex}`);
          if (currentProcessing) {
            currentProcessing.innerHTML = `
            <div class="progress-item status-error">
              <strong>Error:</strong> Request timed out after ${timeoutToUse/1000} seconds.
                <button class="retry-button" data-index="${currentIndex}">Retry</button>
            </div>
          `;
          }
          
          isApiCallInProgress = false;
          processNextComment(currentIndex + 1);
        }, timeoutToUse);
        
        // Log the start of the API request
        console.log(`Starting API request for comment ${comment.id}`);
        unifiedLogger.appendLog({
          message: `Starting API request for comment ${comment.id}`,
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: { commentId: comment.id, prompt }
        });
        
        if (isCancelled) {
          processNextComment(currentIndex + 1);
          return;
        }

        isApiCallInProgress = true;  // Set lock before API call
        
        unifiedLogger.appendLog({
          message: 'Starting API request',
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: {
            model: selectedModel,
            commentId: comment.id,
            instruction: comment.instruction
          }
        });

        // Create a streaming response container
        const currentProcessing = document.getElementById(`processing-${currentIndex}`);
        if (currentProcessing) {
          const streamingContainer = document.createElement('div');
          streamingContainer.className = 'streaming-response';
          streamingContainer.innerHTML = `
            <div>Generating response...</div>
            <div class="streaming-text"></div>
          `;
          currentProcessing.appendChild(streamingContainer);
        }

        // Prepare the API request
        const apiUrl = 'http://localhost:11434/api/generate';
        const requestBody = {
          model: selectedModel,
          prompt: prompt,
          stream: true
        };

        // Make the API request
        fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody),
          signal: signal // Use the AbortController signal
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          
          // Get a reader from the response body stream
          const reader = response.body.getReader();
          let accumulatedResponse = '';
          const streamingText = currentProcessing ? currentProcessing.querySelector('.streaming-text') : null;
          
          // Function to process the stream
          function processStream() {
            return reader.read().then(({ done, value }) => {
              // If the stream is done, process the final response
            if (done) {
              console.log('Stream complete');
                clearTimeout(timeoutId); // Clear the timeout
                
                // Process the accumulated response
                const sanitizedResponse = sanitizeResponse(accumulatedResponse);
                
                // Verify the text location
                verifyTextLocation(comment, sanitizedResponse, currentIndex);
                return;
              }
              
              // Convert the chunk to text
              const chunk = new TextDecoder().decode(value);
              
              try {
                // Process each line in the chunk
                const lines = chunk.split('\n');
            for (const line of lines) {
                  if (line.trim() === '') continue;
                  
                  const data = JSON.parse(line);
                  if (data.response) {
                    accumulatedResponse += data.response;
                    
                    // Update the streaming text display
                    if (streamingText) {
                      streamingText.textContent = accumulatedResponse;
                      streamingText.scrollTop = streamingText.scrollHeight;
                    }
                  }
                }
              } catch (e) {
                console.error('Error processing chunk:', e);
              }
              
              // Continue processing the stream
              return processStream();
            });
          }
          
          // Start processing the stream
          return processStream();
        })
        .catch(error => {
          clearTimeout(timeoutId); // Clear the timeout
          
          // Check if this was an abort error
          if (error.name === 'AbortError') {
            console.log('Fetch aborted due to timeout');
            return; // Already handled in the timeout callback
          }
          
          console.error('API call failed:', error);
          unifiedLogger.appendLog({
            message: 'API call failed',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: {
              commentId: comment.id,
              error: error.toString()
            }
          });
          
          // Update UI to show error
          if (currentProcessing) {
            currentProcessing.innerHTML = `
                          <div class="progress-item status-error">
                <strong>Error:</strong> ${escapeHtml(error.toString())}
                <button class="retry-button" data-index="${currentIndex}">Retry</button>
                          </div>
                        `;
          }
          
          isApiCallInProgress = false;
          processNextComment(currentIndex + 1);
        });
      }
      
      /**
       * Sanitize API response text
       */
      function sanitizeResponse(text) {
        if (!text) return '';
        
        // Remove any markdown code blocks
        text = text.replace(/```[\s\S]*?```/g, '');
        
        // Remove any explanations before or after the edited text
        const lines = text.split('\n');
        let startLine = 0;
        let endLine = lines.length - 1;
        
        // Find the first non-empty line
        while (startLine <= endLine && lines[startLine].trim() === '') {
          startLine++;
        }
        
        // Find the last non-empty line
        while (endLine >= startLine && lines[endLine].trim() === '') {
          endLine--;
        }
        
        // Extract the core content
        const coreContent = lines.slice(startLine, endLine + 1).join('\n');
        
        // Trim leading and trailing quotation marks
        let trimmedContent = coreContent.trim();
        if (trimmedContent.startsWith('"') && trimmedContent.endsWith('"')) {
          trimmedContent = trimmedContent.substring(1, trimmedContent.length - 1);
        }
        
        return trimmedContent.trim();
      }
      
      /**
       * Verify text location and add suggestion
       */
      function verifyTextLocation(comment, suggestedText, currentIndex) {
        const currentProcessing = document.getElementById(`processing-${currentIndex}`);
        
        unifiedLogger.appendLog({
          message: 'Verifying text location',
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: {
            commentId: comment.id,
            suggestedTextLength: suggestedText.length
          }
        });
        
        if (currentProcessing) {
          currentProcessing.innerHTML = `
            <div class="progress-item">
              <div>Verifying text location...</div>
                  </div>
                `;
        }
        
        // Call the server to verify text location
        google.script.run
          .withSuccessHandler(function(result) {
            if (!result || !result.success) {
              unifiedLogger.appendLog({
                message: 'Text location verification failed',
                category: 'ERROR',
                timestamp: new Date().toISOString(),
                data: result
              });
              
              if (currentProcessing) {
                currentProcessing.innerHTML = `
            <div class="progress-item status-error">
                    <strong>Error:</strong> ${escapeHtml(result ? result.error : 'Unknown error')}
                    <button class="retry-button" data-index="${currentIndex}">Retry</button>
            </div>
          `;
              }
              
              isApiCallInProgress = false;
              processNextComment(currentIndex + 1);
              return;
            }
            
            unifiedLogger.appendLog({
              message: 'Text location verified successfully',
              category: 'DEBUG',
              timestamp: new Date().toISOString(),
              data: {
                commentId: comment.id,
                suggestedTextLength: suggestedText.length
              }
            });
            
            // Add the suggestion to the UI for user review
            addRevision(comment, suggestedText);
            
            // Update the processing item to show success
            if (currentProcessing) {
              currentProcessing.innerHTML = `
                <div class="progress-item status-completed">
                  <strong>Completed:</strong> Suggestion ready for review
                </div>
              `;
            }
            
            isApiCallInProgress = false;
            processNextComment(currentIndex + 1);
          })
          .withFailureHandler(function(error) {
            unifiedLogger.appendLog({
              message: 'Text location verification failed',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: error.toString() }
            });
            
            if (currentProcessing) {
              currentProcessing.innerHTML = `
                <div class="progress-item status-error">
                  <strong>Error:</strong> ${escapeHtml(error.toString())}
                  <button class="retry-button" data-index="${currentIndex}">Retry</button>
                </div>
              `;
            }
            
            isApiCallInProgress = false;
            processNextComment(currentIndex + 1);
          })
          .verifyTextLocation(fileId, comment.id, comment.text);
      }
    </script>
  </body>
</html>
