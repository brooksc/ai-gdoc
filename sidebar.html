<!DOCTYPE html>
<html>

  <head>
    <base target="_top">
    <meta charset="utf-8">
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 10px;
        color: #444;
      }
      h3 {
        color: #1a73e8;
        margin-bottom: 15px;
      }
      .container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .model-selector {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      select {
        padding: 8px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      .ai-comment-counter {
        background: #e8f0fe;
        border-radius: 4px;
        padding: 10px;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .counter-badge {
        background: #1a73e8;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }
      button {
        background-color: #1a73e8;
        color: white;
        border: none;
        padding: 10px 16px;
        font-size: 14px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: #1765cc;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }
      
      /* Logging section styles */
      .logging-section {
        margin-top: 15px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #fff;
      }
      
      .logging-header {
        display: flex;
        align-items: center;
        padding: 8px;
        background: #f8f9fa;
        border-bottom: 1px solid #ddd;
        border-radius: 4px 4px 0 0;
      }
      
      .logging-header h4 {
        margin: 0;
        flex-grow: 1;
        color: #1a73e8;
        font-size: 14px;
      }
      
      .copy-button, .clear-button, .refresh-button {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 8px;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
      }
      
      .copy-button:hover, .clear-button:hover, .refresh-button:hover {
        background: #f1f3f4;
      }
      
      .unified-logs {
        width: 100%;
        height: 300px;
        padding: 8px;
        font-family: 'Roboto Mono', monospace;
        font-size: 12px;
        border: none;
        resize: vertical;
        background: #fff;
        color: #444;
        line-height: 1.4;
        white-space: pre-wrap;
        overflow-y: auto;
      }
      
      .unified-logs:focus {
        outline: none;
        border-color: #1a73e8;
      }
      
      /* Add styles for different log categories */
      .log-error { color: #d93025; }
      .log-debug { color: #188038; }
      .log-comment { color: #1a73e8; }
      .log-text { color: #666; }
      .log-state { color: #9334e6; }
      

      .progress-container {
        margin-top: 15px;
      }
      .progress-item {
        padding: 8px;
        border-bottom: 1px solid #eee;
        font-size: 13px;
      }
      .current-processing {
        background: #fef7e0;
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 10px;
      }
      .current-processing h4 {
        margin: 0 0 8px 0;
        color: #b06000;
      }
      .text-block {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        margin: 4px 0;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
      }
      .revision-item {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 12px;
        margin-bottom: 8px;
      }
      .revision-item h4 {
        margin: 0 0 8px 0;
        color: #188038;
      }
      .button-group {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }
      .accept-button {
        background-color: #188038;
      }
      .accept-button:hover {
        background-color: #137333;
      }
      .reject-button {
        background-color: #d93025;
      }
      .reject-button:hover {
        background-color: #c5221f;
      }
      .status {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 11px;
        margin-left: 5px;
      }
      .status-pending {
        background: #f1f3f4;
        color: #444;
      }
      .status-processing {
        background: #fef7e0;
        color: #b06000;
      }
      .status-completed {
        background: #e6f4ea;
        color: #137333;
      }
      .status-error {
        background: #fce8e6;
        color: #c5221f;
      }
      .refresh-models {
        font-size: 12px;
        color: #1a73e8;
        text-decoration: underline;
        cursor: pointer;
        margin-left: auto;
        border: none;
        background: none;
        padding: 0;
      }
      .cancel-button {
        background-color: #5f6368;
      }
      .cancel-button:hover {
        background-color: #494c50;
      }
      .processing-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 16px;
        z-index: 1000;
      }
      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #1a73e8;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .diff-view {
        background: #f8f9fa;
        border-radius: 4px;
        padding: 8px;
        margin: 4px 0;
        font-family: monospace;
        font-size: 12px;
        white-space: pre-wrap;
      }
      .diff-removed {
        background: #fce8e6;
        text-decoration: line-through;
        color: #c5221f;
      }
      .diff-added {
        background: #e6f4ea;
        color: #137333;
      }
    </style>
  </head>
  <body>
    <h3>AI Editor</h3>
    <div class="container">
      <button id="debugButton" style="background-color: #ff9800; margin-bottom: 10px;">Debug: Test First Comment</button>
      
      <!-- Unified logging section -->
      <div class="logging-section">
        <div class="logging-header">
          <h4>Debug Logs</h4>
          <button id="copyLogsButton" class="copy-button" title="Copy logs to clipboard">
            <span class="copy-icon">üìã</span> Copy
          </button>
          <button id="clearLogsButton" class="clear-button" title="Clear logs">
            <span class="clear-icon">üóëÔ∏è</span> Clear
          </button>
          <button id="refreshLogsButton" class="refresh-button" title="Refresh logs">
            <span class="refresh-icon">üîÑ</span> Refresh
          </button>
        </div>
        <textarea id="unifiedLogs" readonly class="unified-logs" 
                  placeholder="Debug logs will appear here..."></textarea>
      </div>
      
      <div class="model-selector">
        <div style="display: flex; align-items: center;">
          <label for="modelSelect">Select Model:</label>
          <button class="refresh-models" id="refreshModels">Refresh</button>
        </div>
        <select id="modelSelect">
          <option value="">Loading models...</option>
        </select>
      </div>
      
      <div class="ai-comment-counter">
        <span>Unprocessed AI Comments:</span>
        <span class="counter-badge" id="commentCount">0</span>
      </div>
      
      <button id="processButton" disabled>Generate Suggestions</button>
      
      <div class="progress-container">
        <div id="currentProcessing"></div>
        <div id="revisionsList"></div>
        <div id="progress"></div>
      </div>
    </div>

    <div id="processingOverlay" class="processing-overlay" style="display: none;">
      <div class="spinner"></div>
      <div id="processingStatus">Processing...</div>
      <button class="cancel-button" onclick="cancelProcessing()">Cancel</button>
    </div>

    <script>
      // Global state
      let commentsList = [];
      let selectedModel = '';
      let isProcessing = false;
      let fileId = '';
      let currentComment = null;
      let isCancelled = false;
      let processingTimeout = null;
      let isApiCallInProgress = false;
      
      /**
       * Handle errors in a user-friendly way
       */
      function handleError(error) {
        const errorMessage = error.toString();
        
        // Log the error
        unifiedLogger.appendLog({
          message: 'Error: ' + errorMessage,
          category: 'ERROR',
          timestamp: new Date().toISOString(),
          data: error
        });
        
        // Update progress UI
        const progressElement = document.getElementById('progress');
        progressElement.innerHTML = `<div class="progress-item status-error">Error: ${escapeHtml(errorMessage)}</div>`;
        
        // Reset state
        isProcessing = false;
        isApiCallInProgress = false;
        currentComment = null;
        
        // Update UI
        updateProcessButtonState();
        hideProcessingOverlay();
        displayCurrentProcessing(null);
      }
      
      // Handle page visibility changes
      document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
          // Save state before page becomes hidden
          try {
            const state = {
              selectedModel,
              isProcessing,
              currentComment,
              commentsList,
              isOpen: true // Add isOpen flag
            };
            sessionStorage.setItem('aiedit_state', JSON.stringify(state));
          } catch (e) {
            console.error('Error saving state:', e);
            unifiedLogger.appendLog({
              message: 'Error saving state',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: e.toString() }
            });
          }
        } else {
          // Page is visible again, check if we need to restore state
          try {
            const savedState = sessionStorage.getItem('aiedit_state');
            if (savedState) {
              const state = JSON.parse(savedState);
              
              // Restore only safe state
              selectedModel = state.selectedModel || '';
              commentsList = state.commentsList || [];
              
              // Reset processing state for safety
              isProcessing = false;
              currentComment = null;
              isCancelled = false;
              isApiCallInProgress = false;
              
              // Update UI
              updateProcessButtonState();
              displayCurrentProcessing(null);
              hideProcessingOverlay();
              
              // Refresh data if sidebar was open
              if (state.isOpen) {
                reopenSidebarUI();
              }
            }
          } catch (e) {
            console.error('Error restoring state:', e);
            unifiedLogger.appendLog({
              message: 'Error restoring state',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: e.toString() }
            });
            // On error, do a clean reload
            cleanup();
            initSidebar();
          }
        }
      });
      
      // Handle beforeunload
      window.addEventListener('beforeunload', function(e) {
        if (isProcessing) {
          // Warn user if processing is ongoing
          e.preventDefault();
          e.returnValue = 'Changes you made may not be saved. Are you sure you want to leave?';
          return e.returnValue;
        }
      });
      
      /**
       * Clean up function for page unload
       */
      function cleanup() {
        if (processingTimeout) {
          clearTimeout(processingTimeout);
          processingTimeout = null;
        }
        
        // Clear state
        isCancelled = true;
        isProcessing = false;
        isApiCallInProgress = false;
        currentComment = null;
        
        // Clear storage
        try {
          sessionStorage.removeItem('aiedit_state');
        } catch (e) {
          console.error('Error clearing state:', e);
          unifiedLogger.appendLog({
            message: 'Error clearing state',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { error: e.toString() }
          });
        }
        
        // Reset UI
        displayCurrentProcessing(null);
        hideProcessingOverlay();
        updateProcessButtonState();
      }

      /**
       * Function to handle reopening the sidebar UI
       */
      function reopenSidebarUI() {
        fetchComments(); // Refresh comments
        fetchModels(); // Refresh models
        updateProcessButtonState(); // Update button state
      }

      // Initialize the sidebar when the page loads
      window.onload = function() {
        initSidebar();
        
        // Try to restore state
        try {
          const savedState = sessionStorage.getItem('aiedit_state');
          if (savedState) {
            const state = JSON.parse(savedState);
            selectedModel = state.selectedModel || '';
            if (selectedModel) {
              document.getElementById('modelSelect').value = selectedModel;
            }
            // Check if sidebar was open
            if (state.isOpen) {
              reopenSidebarUI();
            }
          }
        } catch (e) {
          console.error('Error restoring initial state:', e);
          unifiedLogger.appendLog({
            message: 'Error restoring initial state',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { error: e.toString() }
          });
        }
        
        // Add cleanup handlers
        window.addEventListener('unload', cleanup);
      };
      
      // Debounce function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      
      // Create debounced version of fetchModels
      const debouncedFetchModels = debounce(fetchModels, 1000);
      
      /**
       * Initialize the sidebar
       */
      function initSidebar() {
        document.getElementById('refreshModels').addEventListener('click', debouncedFetchModels);
        document.getElementById('processButton').addEventListener('click', processAIComments);
        document.getElementById('modelSelect').addEventListener('change', handleModelChange);
        
        // Get fileId first
        google.script.run
          .withSuccessHandler(function(id) {
            fileId = id;
            // Initial data loading
            fetchComments();
            fetchModels();
          })
          .withFailureHandler(handleError)
          .getDocumentId();
      }
      
      /**
       * Fetch AI comments from the document
       */
      function fetchComments() {
        document.getElementById('progress').innerHTML = '<div class="progress-item">Fetching AI comments...</div>';
        
        google.script.run
          .withSuccessHandler(updateCommentsList)
          .withFailureHandler(handleError)
          .getAIComments();
      }
      
      /**
       * Update the UI with fetched comments
       */
      function updateCommentsList(comments) {
        if (!comments) {
          handleError("Failed to retrieve comments");
          return;
        }

        commentsList = comments;
        document.getElementById('commentCount').textContent = String(comments.length);
        
        const progressElement = document.getElementById('progress');
        if (comments.length === 0) {
          progressElement.innerHTML = [
            '<div class="progress-item">No unprocessed AI comments found.</div>',
            '<div class="progress-item"><b>How to use:</b></div>',
            '<div class="progress-item">1. Highlight text you want to edit</div>',
            '<div class="progress-item">2. Add a comment starting with "AI:" followed by your instruction</div>',
            '<div class="progress-item">3. Click "Generate Suggestions" to get AI edits</div>',
            '<div class="progress-item">4. Review and accept/reject suggestions</div>',
            '<button id="refreshButton" style="margin-top: 10px; width: 100%;">Refresh Comments</button>'
          ].join('');
          
          // Clean up old event listener if it exists
          const oldButton = document.getElementById('refreshButton');
          const newButton = oldButton.cloneNode(true);
          oldButton.parentNode.replaceChild(newButton, oldButton);
          newButton.addEventListener('click', fetchComments);
        } else {
          progressElement.innerHTML = '<div class="progress-item">Found ' + comments.length + ' unprocessed AI comments ready for processing.</div>';
        }
        
        updateProcessButtonState();
      }
      
      /**
       * Escape HTML to prevent XSS
       */
      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
      
      /**
       * Display the currently processing comment
       */
      function displayCurrentProcessing(comment) {
        const container = document.getElementById('currentProcessing');
        if (!comment) {
          container.innerHTML = '';
          return;
        }
        
        container.innerHTML = `
          <div class="current-processing">
            <h4>Currently Processing:</h4>
            <div><strong>Instruction:</strong></div>
            <div class="text-block">${escapeHtml(comment.instruction)}</div>
            <div><strong>Original Text:</strong></div>
            <div class="text-block">${escapeHtml(comment.text)}</div>
          </div>
        `;
      }
      
      /**
       * Show processing overlay
       */
      function showProcessingOverlay(message) {
        const overlay = document.getElementById('processingOverlay');
        document.getElementById('processingStatus').textContent = message || 'Processing...';
        overlay.style.display = 'flex';
      }
      
      /**
       * Hide processing overlay
       */
      function hideProcessingOverlay() {
        document.getElementById('processingOverlay').style.display = 'none';
      }
      
      /**
       * Cancel ongoing processing
       */
      function cancelProcessing() {
        isCancelled = true;
        if (processingTimeout) {
          clearTimeout(processingTimeout);
          processingTimeout = null;
        }
        isProcessing = false;
        currentComment = null;
        displayCurrentProcessing(null);
        updateProcessButtonState();
        hideProcessingOverlay();
        document.getElementById('progress').innerHTML = 
          '<div class="progress-item">Processing cancelled by user.</div>';
      }
      
      /**
       * Show diff between original and suggested text
       */
      function createDiffView(originalText, suggestedText) {
        return `
          <div class="diff-view">
            <div class="diff-removed">${escapeHtml(originalText)}</div>
            <div class="diff-added">${escapeHtml(suggestedText)}</div>
          </div>
        `;
      }
      
      /**
       * Add a revision to the list
       */
      function addRevision(comment, suggestedText) {
        const container = document.getElementById('revisionsList');
        const revisionElement = document.createElement('div');
        revisionElement.className = 'revision-item';
        revisionElement.id = 'revision-' + comment.id;
        
        // Create the content container first
        const contentContainer = document.createElement('div');
        contentContainer.innerHTML = `
          <h4>Suggested Edit:</h4>
          <div><strong>Instruction:</strong></div>
          <div class="text-block">${escapeHtml(comment.instruction)}</div>
          <div><strong>Changes:</strong></div>
          ${createDiffView(comment.text, suggestedText)}
        `;
        revisionElement.appendChild(contentContainer);
        
        // Create accept and reject buttons separately
        const buttonGroup = document.createElement('div');
        buttonGroup.className = 'button-group';
        
        const acceptButton = document.createElement('button');
        acceptButton.className = 'accept-button';
        acceptButton.textContent = 'Accept';
        acceptButton.addEventListener('click', () => handleAccept(comment.id, suggestedText));
        
        const rejectButton = document.createElement('button');
        rejectButton.className = 'reject-button';
        rejectButton.textContent = 'Reject';
        rejectButton.addEventListener('click', () => handleReject(comment.id, suggestedText));
        
        buttonGroup.appendChild(acceptButton);
        buttonGroup.appendChild(rejectButton);
        revisionElement.appendChild(buttonGroup);
        
        container.insertBefore(revisionElement, container.firstChild);
      }
      
      /**
       * Handle accepting a suggestion
       */
      function handleAccept(commentId, suggestedText) {
        const revisionElement = document.getElementById('revision-' + commentId);
        if (!revisionElement) return;

        unifiedLogger.appendLog({
          message: 'Starting accept operation',
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: {
            commentId: commentId,
            suggestedTextLength: suggestedText.length,
            fileId: fileId
          }
        });

        revisionElement.querySelector('.button-group').innerHTML = '<div class="status status-processing">Applying changes...</div>';

        google.script.run
          .withSuccessHandler(function() {
            unifiedLogger.appendLog({
              message: 'Changes applied successfully',
              category: 'DEBUG',
              timestamp: new Date().toISOString(),
              data: { commentId: commentId }
            });
            revisionElement.innerHTML = '<div class="status status-completed">Changes applied successfully</div>';
            setTimeout(() => {
              revisionElement.remove();
              fetchComments(); // Refresh comment list
            }, 2000);
          })
          .withFailureHandler(function(error) {
            unifiedLogger.appendLog({
              message: 'Failed to apply changes',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: {
                commentId: commentId,
                error: error.toString()
              }
            });
            
            const escapedError = escapeHtml(error.toString());
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            buttonGroup.innerHTML = `
              <div class="status status-error">Error: ${escapedError}</div>
              <div class="button-group">
                <button class="accept-button">Retry Accept</button>
                <button class="reject-button">Reject Instead</button>
              </div>`;
            
            const oldButtonGroup = revisionElement.querySelector('.button-group');
            oldButtonGroup.replaceWith(buttonGroup);
            
            // Add event listeners for retry/reject
            const retryButton = buttonGroup.querySelector('.accept-button');
            const rejectButton = buttonGroup.querySelector('.reject-button');
            retryButton.addEventListener('click', () => handleAccept(commentId, suggestedText));
            rejectButton.addEventListener('click', () => handleReject(commentId, suggestedText));
          })
          .applyAIEdit(fileId, commentId, suggestedText, true);
      }
      
      /**
       * Handle rejecting a suggestion
       */
      function handleReject(commentId, suggestedText) {
        const revisionElement = document.getElementById('revision-' + commentId);
        if (!revisionElement) return;
        
        unifiedLogger.appendLog({
          message: 'Starting reject operation',
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: {
            commentId: commentId,
            suggestedTextLength: suggestedText.length,
            fileId: fileId
          }
        });
        
        revisionElement.querySelector('.button-group').innerHTML = '<div class="status status-processing">Rejecting suggestion...</div>';
        
        google.script.run
          .withSuccessHandler(function() {
            unifiedLogger.appendLog({
              message: 'Changes rejected successfully',
              category: 'DEBUG',
              timestamp: new Date().toISOString()
            });
            revisionElement.innerHTML = '<div class="status status-completed">Suggestion rejected</div>';
            setTimeout(() => {
              revisionElement.remove();
              fetchComments(); // Refresh comment list
            }, 2000);
          })
          .withFailureHandler(function(error) {
            unifiedLogger.appendLog({
              message: 'Failed to reject changes',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: error.toString() }
            });
            
            const escapedError = escapeHtml(error.toString());
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'button-group';
            buttonGroup.innerHTML = `
              <div class="status status-error">Error: ${escapedError}</div>
              <div class="button-group">
                <button class="reject-button">Retry Reject</button>
                <button class="accept-button">Accept Instead</button>
              </div>`;
            
            const oldButtonGroup = revisionElement.querySelector('.button-group');
            oldButtonGroup.replaceWith(buttonGroup);
            
            // Add event listeners for retry/reject
            const retryButton = buttonGroup.querySelector('.reject-button');
            const acceptButton = buttonGroup.querySelector('.accept-button');
            retryButton.addEventListener('click', () => handleReject(commentId, suggestedText));
            acceptButton.addEventListener('click', () => handleAccept(commentId, suggestedText));
          })
          .applyAIEdit(fileId, commentId, suggestedText, false);
      }
      
      /**
       * Populate the model dropdown with available models
       */
      function fetchModels() {
        const modelSelect = document.getElementById('modelSelect');
        modelSelect.innerHTML = '<option value="">Loading models...</option>';
        modelSelect.disabled = true;

        fetch('http://localhost:11434/api/tags', {
          mode: 'cors',
          headers: {
            'Accept': 'application/json'
          }
        })
        .then(function(response) {
          if (!response.ok) {
            throw new Error('Failed to fetch models: ' + response.statusText);
          }
          return response.json();
        })
        .then(function(data) {
          modelSelect.disabled = false;
          if (data && data.models) {
            modelSelect.innerHTML = '';
            if (!data.models || data.models.length === 0) {
              modelSelect.innerHTML = '<option value="">No models available</option>';
              return;
            }
            modelSelect.appendChild(new Option('Select a model...', ''));

            data.models.forEach(function(model) {
              const option = new Option(model.name, model.name);
              if (model.name === selectedModel) {
                option.selected = true;
              }
              modelSelect.appendChild(option);
            });
            updateProcessButtonState();
          } else {
            throw new Error('Invalid response from Ollama API');
          }
        })
        .catch(function(error) {
          console.error('Error fetching models:', error);
          unifiedLogger.appendLog({
            message: 'Error fetching models',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { error: error.toString() }
          });
          modelSelect.disabled = false;
          modelSelect.innerHTML =
            '<option value="">Error: Cannot connect to Ollama</option>' +
            '<option value="" disabled>Make sure Ollama is running on port 11434</option>';
        });
      }
      
      /**
       * Handle model selection change
       */
      function handleModelChange(e) {
        selectedModel = e.target.value;
        updateProcessButtonState();
        
        // Save the selected model
        google.script.run
          .withFailureHandler(function(error) {
            console.error('Failed to save model selection:', error);
            unifiedLogger.appendLog({
              message: 'Failed to save model selection',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: error.toString() }
            });
          })
          .saveSelectedModel(selectedModel);
      }
      
      /**
       * Update process button enabled/disabled state
       */
      function updateProcessButtonState() {
        const button = document.getElementById('processButton');
        button.disabled = isProcessing || commentsList.length === 0 || !selectedModel;
      }
      
      /**
       * Copy session logs to clipboard
       */
      function copySessionLogs(container) {
        const logText = Array.from(container.querySelectorAll('div'))
          .slice(1) // Skip the header div
          .map(div => div.textContent)
          .join('\n');
        
        navigator.clipboard.writeText(logText).then(
          () => {
            const btn = container.querySelector('button');
            const originalText = btn.textContent;
            btn.textContent = '‚úì';
            setTimeout(() => {
              btn.textContent = originalText;
            }, 1000);
          },
          (err) => {
            console.error('Failed to copy logs:', err);
            const btn = container.querySelector('button');
            btn.textContent = '‚úó';
            setTimeout(() => {
              btn.textContent = 'üìã';
            }, 1000);
          }
        );
      }
      
      /**
       * Process all AI comments sequentially
       */
      function processAIComments() {
        if (isProcessing || commentsList.length === 0 || !selectedModel) {
          return;
        }
        
        // Create a new container for this processing session's logs
        const progressElement = document.getElementById('progress');
        const sessionContainer = document.createElement('div');
        sessionContainer.className = 'progress-item';
        sessionContainer.style.marginBottom = '20px';
        
        const headerContainer = document.createElement('div');
        headerContainer.style.display = 'flex';
        headerContainer.style.alignItems = 'center';
        headerContainer.style.gap = '8px';
        
        const headerText = document.createElement('div');
        headerText.innerHTML = '<strong>Processing Session Logs:</strong>';
        
        const copyButton = document.createElement('button');
        copyButton.style.padding = '4px 8px';
        copyButton.style.fontSize = '12px';
        copyButton.style.minWidth = '32px';
        copyButton.title = 'Copy logs to clipboard';
        copyButton.textContent = 'üìã';
        copyButton.addEventListener('click', () => copySessionLogs(sessionContainer));
        
        headerContainer.appendChild(headerText);
        headerContainer.appendChild(copyButton);
        sessionContainer.appendChild(headerContainer);
        
        progressElement.insertBefore(sessionContainer, progressElement.firstChild);
        
        // Don't clear revisionsList anymore
        isCancelled = false;
        isProcessing = true;
        isApiCallInProgress = false;  // Reset API call lock
        updateProcessButtonState();
        showProcessingOverlay('Preparing to process comments...');
        
        // Start processing after a short delay
        processingTimeout = setTimeout(() => processNextComment(0, sessionContainer), 500);
      }
      
      /**
       * Process comments one by one
       */
      function processNextComment(index) {
        if (isCancelled || index >= commentsList.length || isApiCallInProgress) {
          if (!isApiCallInProgress) {
            isProcessing = false;
            currentComment = null;
            displayCurrentProcessing(null);
            updateProcessButtonState();
            hideProcessingOverlay();
            
            if (!isCancelled && index > 0) {
              unifiedLogger.appendLog({
                message: 'Finished processing all comments',
                category: 'DEBUG',
                timestamp: new Date().toISOString()
              });
            }
          }
          return;
        }
        
        currentComment = commentsList[index];
        displayCurrentProcessing(currentComment);
        showProcessingOverlay(`Processing comment ${index + 1} of ${commentsList.length}...`);
        
        const prompt = currentComment.instruction + '\n\nText to edit:\n' + currentComment.text + 
                      '\n\nPlease provide only the edited text without any explanations or formatting:';
        
        // Add delay between API calls
        processingTimeout = setTimeout(() => callOllamaAPI(currentComment, prompt, index), 1000);
      }
      
      /**
       * Debug function to test comment processing
       */
      function debugFirstComment() {
        const debugButton = document.getElementById('debugButton');
        debugButton.disabled = true;
        debugButton.textContent = 'Testing...';
        
        unifiedLogger.appendLog({
          message: 'Starting debug test',
          category: 'DEBUG',
          timestamp: new Date().toISOString()
        });

        // Get first comment
        google.script.run
          .withSuccessHandler(function(comments) {
            if (!comments || comments.length === 0) {
              unifiedLogger.appendLog({
                message: 'No comments found',
                category: 'DEBUG',
                timestamp: new Date().toISOString()
              });
              debugButton.textContent = 'No Comments ‚úó';
              setTimeout(() => {
                debugButton.disabled = false;
                debugButton.textContent = 'Debug: Test First Comment';
              }, 2000);
              return;
            }

            const comment = comments[0];
            unifiedLogger.appendLog({
              message: 'Found first comment',
              category: 'DEBUG',
              timestamp: new Date().toISOString(),
              data: comment
            });

            // Simulate API response
            const simulatedResponse = "It works!!";
            unifiedLogger.appendLog({
              message: 'Simulated API response',
              category: 'DEBUG',
              timestamp: new Date().toISOString(),
              data: { response: simulatedResponse }
            });

            // Verify text location
            google.script.run
              .withSuccessHandler(function(result) {
                if (!result || !result.success) {
                  unifiedLogger.appendLog({
                    message: 'Text location verification failed',
                    category: 'ERROR',
                    timestamp: new Date().toISOString(),
                    data: result
                  });
                  throw new Error(result.error || 'Could not verify text location');
                }

                unifiedLogger.appendLog({
                  message: 'Text location verified successfully',
                  category: 'DEBUG',
                  timestamp: new Date().toISOString(),
                  data: result
                });

                // Add the suggestion to the UI for user review
                addRevision(comment, simulatedResponse);
                
                debugButton.textContent = 'Test Completed ‚úì';
                setTimeout(() => {
                  debugButton.disabled = false;
                  debugButton.textContent = 'Debug: Test First Comment';
                }, 2000);
              })
              .withFailureHandler(function(error) {
                unifiedLogger.appendLog({
                  message: 'Text location verification failed',
                  category: 'ERROR',
                  timestamp: new Date().toISOString(),
                  data: { error: error.toString() }
                });
                debugButton.textContent = 'Test Failed ‚úó';
                debugButton.style.backgroundColor = '#d93025';
                setTimeout(() => {
                  debugButton.disabled = false;
                  debugButton.textContent = 'Debug: Test First Comment';
                  debugButton.style.backgroundColor = '#ff9800';
                }, 2000);
              })
              .verifyTextLocation(fileId, comment.id, comment.text);
          })
          .withFailureHandler(function(error) {
            unifiedLogger.appendLog({
              message: 'Failed to get comments',
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: error.toString() }
            });
            debugButton.textContent = 'Test Failed ‚úó';
            debugButton.style.backgroundColor = '#d93025';
            setTimeout(() => {
              debugButton.disabled = false;
              debugButton.textContent = 'Debug: Test First Comment';
              debugButton.style.backgroundColor = '#ff9800';
            }, 2000);
          })
          .getAIComments();
      }

      // Add debug button handler
      document.getElementById('debugButton').addEventListener('click', debugFirstComment);

      /**
       * Call Ollama API to process a comment
       */
      function callOllamaAPI(comment, prompt, currentIndex) {
        if (isCancelled) {
          processNextComment(currentIndex + 1);
          return;
        }

        isApiCallInProgress = true;  // Set lock before API call
        
        unifiedLogger.appendLog({
          message: 'Starting API request',
          category: 'DEBUG',
          timestamp: new Date().toISOString(),
          data: {
            model: selectedModel,
            commentId: comment.id,
            instruction: comment.instruction
          }
        });

        // Create AbortController for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

        fetch('http://localhost:11434/api/generate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: selectedModel,
            prompt: prompt,
            stream: false
          }),
          signal: controller.signal
        })
        .then(function(response) {
          clearTimeout(timeoutId);
          isApiCallInProgress = false;
          if (!response.ok) {
            throw new Error('Network error: ' + response.statusText);
          }
          return response.json();
        })
        .then(function(data) {
          unifiedLogger.appendLog({
            message: 'Received API response',
            category: 'DEBUG',
            timestamp: new Date().toISOString(),
            data: {
              response: data.response,
              commentId: comment.id
            }
          });

          if (isCancelled) {
            processNextComment(currentIndex + 1);
            return;
          }
          
          if (!data.response) {
            throw new Error('Invalid response from Ollama API');
          }
          
          // Sanitize the response text
          const sanitizedResponse = data.response.replace(/[\u0000-\u001F\u007F-\u009F]/g, '')
            .replace(/\u2028|\u2029/g, '\n')
            .trim();

          unifiedLogger.appendLog({
            message: 'Verifying text location',
            category: 'DEBUG',
            timestamp: new Date().toISOString(),
            data: {
              commentId: comment.id,
              textLength: comment.text.length
            }
          });

          // First verify we can find the text location
          google.script.run
            .withSuccessHandler(function(result) {
              if (!result || !result.success) {
                unifiedLogger.appendLog({
                  message: 'Text location verification failed',
                  category: 'ERROR',
                  timestamp: new Date().toISOString(),
                  data: result
                });
                throw new Error(result.error || 'Could not verify text location before replacement');
              }

              unifiedLogger.appendLog({
                message: 'Text location verified successfully',
                category: 'DEBUG',
                timestamp: new Date().toISOString(),
                data: result
              });

              // Add the suggestion to the UI for user review
              addRevision(comment, sanitizedResponse);
              
              // Process next comment after a delay
              processingTimeout = setTimeout(() => processNextComment(currentIndex + 1), 1000);
            })
            .withFailureHandler(function(error) {
              console.error("aiedit: Error verifying text location:", error);
              const errorMessage = escapeHtml(error.toString());
              unifiedLogger.appendLog({
                message: 'Text location verification failed',
                category: 'ERROR',
                timestamp: new Date().toISOString(),
                data: { error: error.toString() }
              });
              
              if (!isCancelled) {
                unifiedLogger.appendLog({
                  message: `Error processing comment ${currentIndex + 1}`,
                  category: 'ERROR',
                  timestamp: new Date().toISOString(),
                  data: { error: errorMessage }
                });
                
                processingTimeout = setTimeout(() => processNextComment(currentIndex + 1), 2000);
              }
            })
            .verifyTextLocation(fileId, comment.id, comment.text);
        })
        .catch(function(error) {
          clearTimeout(timeoutId);
          isApiCallInProgress = false;
          
          // Handle abort error specifically
          if (error.name === 'AbortError') {
            error = new Error('Request timed out after 30 seconds');
          }
          
          console.error("aiedit: Error in Ollama API call:", error);
          const errorMessage = escapeHtml(error.toString());
          unifiedLogger.appendLog({
            message: 'API call failed',
            category: 'ERROR',
            timestamp: new Date().toISOString(),
            data: { error: error.toString() }
          });
          
          if (!isCancelled) {
            unifiedLogger.appendLog({
              message: `Error processing comment ${currentIndex + 1}`,
              category: 'ERROR',
              timestamp: new Date().toISOString(),
              data: { error: errorMessage }
            });
            
            processingTimeout = setTimeout(() => processNextComment(currentIndex + 1), 2000);
          }
        });
      }

      /**
       * Copy server logs to clipboard
       */
      function copyServerLogs() {
        const button = document.getElementById('copyServerLogsButton');
        const originalText = button.textContent;
        button.disabled = true;
        button.textContent = 'Fetching logs...';
        
        google.script.run
          .withSuccessHandler(function(logs) {
            if (!logs) {
              button.textContent = 'No logs found';
              setTimeout(() => {
                button.disabled = false;
                button.textContent = originalText;
              }, 2000);
              return;
            }
            
            // Parse logs if they're in JSON format
            let formattedLogs;
            try {
              const parsedLogs = JSON.parse(logs);
              formattedLogs = JSON.stringify(parsedLogs, null, 2);
            } catch (e) {
              formattedLogs = logs; // Use as-is if not JSON
            }
            
            navigator.clipboard.writeText(formattedLogs).then(
              function() {
                button.textContent = 'Copied! ‚úì';
                setTimeout(() => {
                  button.disabled = false;
                  button.textContent = originalText;
                }, 2000);
              },
              function(err) {
                console.error('Failed to copy logs:', err);
                button.textContent = 'Failed to copy ‚úó';
                setTimeout(() => {
                  button.disabled = false;
                  button.textContent = originalText;
                }, 2000);
              }
            );
          })
          .withFailureHandler(function(error) {
            console.error('Failed to fetch logs:', error);
            button.textContent = 'Error fetching logs ‚úó';
            setTimeout(() => {
              button.disabled = false;
              button.textContent = originalText;
            }, 2000);
          })
          .getServerLogs();
      }

      // Unified logging system
      const unifiedLogger = {
        get logElement() {
          const element = document.getElementById('unifiedLogs');
          if (!element) {
            console.error('Unified logs element not found');
            return null;
          }
          return element;
        },
        maxLogSize: 50000,
        
        formatTimestamp: function(isoString) {
          const date = new Date(isoString);
          return date.toLocaleTimeString();
        },
        
        appendLog: function(entry) {
          if (!this.logElement) {
            console.error('Cannot append log: element not found');
            return;
          }

          const timestamp = entry.timestamp ? this.formatTimestamp(entry.timestamp) : new Date().toLocaleTimeString();
          let logText = `[${timestamp}] `;
          
          if (entry.category) {
            logText += `[${entry.category.toUpperCase()}] `;
          }
          
          logText += entry.message;
          
          if (entry.data) {
            try {
              const formattedData = typeof entry.data === 'string' ? 
                entry.data : 
                JSON.stringify(entry.data, null, 2);
              logText += '\n' + formattedData;
            } catch (e) {
              logText += '\nError formatting data: ' + e.message;
            }
          }
          
          const currentValue = this.logElement.value;
          this.logElement.value += (currentValue ? '\n' : '') + logText;
          
          if (this.logElement.value.length > this.maxLogSize) {
            const excess = this.logElement.value.length - this.maxLogSize;
            this.logElement.value = '...\n[Truncated]\n' + 
              this.logElement.value.substring(excess + 100);
          }
          
          this.logElement.scrollTop = this.logElement.scrollHeight;
        },
        
        clear: function() {
          if (!this.logElement) {
            console.error('Cannot clear logs: element not found');
            return;
          }
          this.logElement.value = '';
          this.appendLog({ 
            message: 'Logs cleared',
            category: 'DEBUG',
            timestamp: new Date().toISOString()
          });
        },
        
        copy: async function() {
          try {
            if (!this.logElement) throw new Error('Logs element not found');
            await navigator.clipboard.writeText(this.logElement.value);
            this.appendLog({ 
              message: 'Logs copied to clipboard',
              category: 'DEBUG',
              timestamp: new Date().toISOString()
            });
          } catch (e) {
            // Fallback method
            if (!this.logElement) throw new Error('Logs element not found');
            this.logElement.select();
            try {
              document.execCommand('copy');
              this.appendLog({ 
                message: 'Logs copied using fallback method',
                category: 'DEBUG',
                timestamp: new Date().toISOString()
              });
            } catch (fallbackError) {
              this.appendLog({ 
                message: 'Please manually copy the logs',
                category: 'ERROR',
                timestamp: new Date().toISOString(),
                data: { error: fallbackError.message }
              });
            }
          }
        },
        
        refresh: function() {
          google.script.run
            .withSuccessHandler((response) => {
              if (response.success) {
                this.appendLog({
                  message: 'Server logs retrieved',
                  category: 'DEBUG',
                  timestamp: new Date().toISOString(),
                  data: response.metadata
                });
                
                const logs = response.logs.split('\n');
                logs.forEach(log => {
                  try {
                    const parsed = JSON.parse(log);
                    this.appendLog(parsed);
                  } catch (e) {
                    this.appendLog({
                      message: log,
                      category: 'DEBUG',
                      timestamp: new Date().toISOString()
                    });
                  }
                });
              } else {
                this.appendLog({
                  message: 'Failed to retrieve server logs',
                  category: 'ERROR',
                  timestamp: new Date().toISOString(),
                  data: response.error
                });
              }
            })
            .withFailureHandler((error) => {
              this.appendLog({
                message: 'Error refreshing logs',
                category: 'ERROR',
                timestamp: new Date().toISOString(),
                data: error.toString()
              });
            })
            .getServerLogs();
        }
      };
      
      // Initialize logging controls
      document.getElementById('copyLogsButton').addEventListener('click', () => unifiedLogger.copy());
      document.getElementById('clearLogsButton').addEventListener('click', () => unifiedLogger.clear());
      document.getElementById('refreshLogsButton').addEventListener('click', () => unifiedLogger.refresh());
      
      // Override console.log and console.error
      const originalConsoleLog = console.log;
      const originalConsoleError = console.error;
      
      console.log = function() {
        const args = Array.from(arguments);
        if (typeof unifiedLogger !== 'undefined' && unifiedLogger.appendLog) {
          unifiedLogger.appendLog({
            message: args.join(' '),
            category: 'DEBUG',
            timestamp: new Date().toISOString()
          });
        }
        originalConsoleLog.apply(console, args);
      };
      
      console.error = function() {
        const args = Array.from(arguments);
        if (typeof unifiedLogger !== 'undefined' && unifiedLogger.appendLog) {
          unifiedLogger.appendLog({
            message: args.join(' '),
            category: 'ERROR',
            timestamp: new Date().toISOString()
          });
        }
        originalConsoleError.apply(console, args);
      };
      

      
      // Initialize logger
      unifiedLogger.appendLog({
        message: 'Debug logging system initialized',
        category: 'debug',
        timestamp: new Date().toISOString()
      });
    </script>
  </body>
</html>
